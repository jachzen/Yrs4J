package at.yrs4j.api;

import at.yrs4j.yrslib.*;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.DoubleByReference;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.LongByReference;

import java.nio.IntBuffer;

/**
 * JNA Wrapper for library <b>YrsLib</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface YrsLibNativeInterface extends Library {
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_EVENT_KEY_CHANGE_UPDATE = 6;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_JSON_NULL = -1;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int ERR_CODE_OTHER = 6;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_JSON_STR = -5;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_TEXT = 3;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_EVENT_KEY_CHANGE_DELETE = 5;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_DOC = 7;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_JSON_UNDEF = 0;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int ERR_CODE_UNEXPECTED_VALUE = 4;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int ERR_CODE_IO = 1;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_UNDEFINED = 9;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_ARRAY = 1;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_EVENT_KEY_CHANGE_ADD = 4;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int ERR_CODE_VAR_INT = 2;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_EVENT_PATH_KEY = 1;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_OFFSET_BYTES = 0;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_XML_TEXT = 5;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_FALSE = 0;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_XML_FRAG = 6;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_MAP = 2;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_JSON_NUM = -7;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_JSON_BUF = -4;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int ERR_CODE_INVALID_JSON = 5;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_EVENT_CHANGE_DELETE = 2;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int ERR_CODE_EOS = 3;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_XML_ELEM = 4;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_KIND_UNDO = 0;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int YCHANGE_ADD = 1;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_EVENT_CHANGE_RETAIN = 3;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_JSON_INT = -6;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_OFFSET_UTF16 = 1;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int YCHANGE_RETAIN = 0;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_EVENT_CHANGE_ADD = 1;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_TRUE = 1;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_KIND_REDO = 1;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_JSON_BOOL = -8;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_JSON_MAP = -2;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_EVENT_PATH_INDEX = 2;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int YCHANGE_REMOVE = -1;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int ERR_NOT_ENOUGH_MEMORY = 7;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_JSON_ARR = -3;
    /**
     * <i>native declaration : libyrs.h</i>
     */
    int Y_WEAK_LINK = 8;

    /**
     * <i>native declaration : libyrs.h:2103</i>
     */
    interface ydoc_observe_updates_v1_cb_callback extends Callback {
        void apply(Pointer voidPtr1, int uint32_t1, Pointer charPtr1);
    }

    /**
     * <i>native declaration : libyrs.h:2104</i>
     */
    interface ydoc_observe_updates_v2_cb_callback extends Callback {
        void apply(Pointer voidPtr1, int uint32_t1, Pointer charPtr1);
    }

    /**
     * <i>native declaration : libyrs.h:2105</i>
     */
    interface ydoc_observe_after_transaction_cb_callback extends Callback {
        void apply(Pointer voidPtr1, YrsAfterTransactionEvent YrsAfterTransactionEventPtr1);
    }

    /**
     * <i>native declaration : libyrs.h:2106</i>
     */
    interface ydoc_observe_subdocs_cb_callback extends Callback {
        void apply(Pointer voidPtr1, YrsSubdocsEvent YrsSubdocsEventPtr1);
    }

    /**
     * <i>native declaration : libyrs.h:2107</i>
     */
    interface ydoc_observe_clear_cb_callback extends Callback {
        void apply(Pointer voidPtr1, YrsDoc YrsDocPtr1);
    }

    /**
     * <i>native declaration : libyrs.h:2108</i>
     */
    interface ytext_observe_cb_callback extends Callback {
        void apply(Pointer voidPtr1, YrsTextEvent YrsTextEventPtr1);
    }

    /**
     * <i>native declaration : libyrs.h:2109</i>
     */
    interface ymap_observe_cb_callback extends Callback {
        void apply(Pointer voidPtr1, YrsMapEvent YrsMapEventPtr1);
    }


    /**
     * <i>native declaration : libyrs.h:2110</i>
     */
    interface yarray_observe_cb_callback extends Callback {
        void apply(Pointer voidPtr1, YrsArrayEvent YrsArrayEventPtr1);
    }


    /**
     * <i>native declaration : libyrs.h:2111</i>
     */
    interface yxmlelem_observe_cb_callback extends Callback {
        void apply(Pointer voidPtr1, YrsXmlEvent YrsXmlEventPtr1);
    }


    /**
     * <i>native declaration : libyrs.h:2112</i>
     */
    interface yxmltext_observe_cb_callback extends Callback {
        void apply(Pointer voidPtr1, YrsXmlTextEvent YrsXmlTextEventPtr1);
    }


    /**
     * <i>native declaration : libyrs.h:2113</i>
     */
    interface yobserve_deep_cb_callback extends Callback {
        void apply(Pointer voidPtr1, int uint32_t1, YrsEvent YrsEventPtr1);
    }


    /**
     * <i>native declaration : libyrs.h:2114</i>
     */
    interface yundo_manager_observe_added_cb_callback extends Callback {
        void apply(Pointer voidPtr1, YrsUndoEvent yrsUndoEventPtr1);
    }


    /**
     * <i>native declaration : libyrs.h:2115</i>
     */
    interface yundo_manager_observe_popped_cb_callback extends Callback {
        void apply(Pointer voidPtr1, YrsUndoEvent yrsUndoEventPtr1);
    }


    /**
     * <i>native declaration : libyrs.h:2116</i>
     */
    interface yweak_observe_cb_callback extends Callback {
        void apply(Pointer voidPtr1, YrsWeakLinkEvent YWeakLinkEventPtr1);
    }


    /**
     * Returns default ceonfiguration for `YrsOptions`.<br>
     * Original signature : <code>YrsOptions yoptions()</code><br>
     * <i>native declaration : libyrs.h:715</i>
     */
    YrsOptions.ByValue yoptions();

    /**
     * Releases all memory-allocated resources bound to given document.<br>
     * Original signature : <code>void ydoc_destroy(YrsDoc*)</code><br>
     * <i>native declaration : libyrs.h:720</i>
     */
    void ydoc_destroy(YrsDoc value);

    /**
     * Frees all memory-allocated resources bound to a given [YrsMapEntry].<br>
     * Original signature : <code>void ymap_entry_destroy(YrsMapEntry*)</code><br>
     * <i>native declaration : libyrs.h:725</i>
     */
    void ymap_entry_destroy(YrsMapEntry value);

    /**
     * Frees all memory-allocated resources bound to a given [YrsXmlAttr].<br>
     * Original signature : <code>void yxmlattr_destroy(YrsXmlAttr*)</code><br>
     * <i>native declaration : libyrs.h:730</i>
     */
    void yxmlattr_destroy(YrsXmlAttr attr);


    /**
     * Frees all memory-allocated resources bound to a given UTF-8 null-terminated string returned from
     * <br>
     * Yrs document API. Yrs strings don't use libc malloc, so calling `free()` on them will fault.<br>
     * Original signature : <code>void ystring_destroy(char*)</code><br>
     * <i>native declaration : libyrs.h:736</i>
     */
    void ystring_destroy(Pointer str);

    /**
     * Frees all memory-allocated resources bound to a given binary returned from Yrs document API.
     * <br>
     * Unlike strings binaries are not null-terminated and can contain null characters inside,
     * <br>
     * therefore a size of memory to be released must be explicitly provided.
     * <br>
     * Yrs binaries don't use libc malloc, so calling `free()` on them will fault.<br>
     * Original signature : <code>void ybinary_destroy(char*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:744</i>
     */
    void ybinary_destroy(Pointer ptr, int len);

    /**
     * Creates a new [YDocImpl] instance with a randomized unique client identifier.
     * <br>
     * <br>
     * Use [ydoc_destroy] in order to release created [YDocImpl] resources.<br>
     * Original signature : <code>YrsDoc* ydoc_new()</code><br>
     * <i>native declaration : libyrs.h:751</i>
     */
    YrsDoc ydoc_new();

    /**
     * Creates a shallow clone of a provided `doc` - it's realized by increasing the ref-count
     * <br>
     * value of the document. In result both input and output documents point to the same instance.
     * <br>
     * <br>
     * Documents created this way can be destroyed via [ydoc_destroy] - keep in mind, that the memory
     * <br>
     * will still be persisted until all strong references are dropped.<br>
     * Original signature : <code>YrsDoc* ydoc_clone(YrsDoc*)</code><br>
     * <i>native declaration : libyrs.h:760</i>
     */
    YrsDoc ydoc_clone(YrsDoc doc);

    /**
     * Creates a new [YDocImpl] instance with a specified `options`.
     * <br>
     * <br>
     * Use [ydoc_destroy] in order to release created [YDocImpl] resources.<br>
     * Original signature : <code>YrsDoc* ydoc_new_with_options(YrsOptions)</code><br>
     * <i>native declaration : libyrs.h:767</i>
     */
    YrsDoc ydoc_new_with_options(YrsOptions.ByValue options);

    /**
     * Returns a unique client identifier of this [YDocImpl] instance.<br>
     * Original signature : <code>uint64_t ydoc_id(YrsDoc*)</code><br>
     * <i>native declaration : libyrs.h:772</i>
     */
    long ydoc_id(YrsDoc doc);

    /**
     * Returns a unique document identifier of this [YDocImpl] instance.
     * <br>
     * <br>
     * Generated string resources should be released using [ystring_destroy] function.<br>
     * Original signature : <code>char* ydoc_guid(YrsDoc*)</code><br>
     * <i>native declaration : libyrs.h:779</i>
     */
    Pointer ydoc_guid(YrsDoc doc);

    /**
     * Returns a collection identifier of this [YDocImpl] instance.
     * <br>
     * If none was defined, a `NULL` will be returned.
     * <br>
     * <br>
     * Generated string resources should be released using [ystring_destroy] function.<br>
     * Original signature : <code>char* ydoc_collection_id(YrsDoc*)</code><br>
     * <i>native declaration : libyrs.h:787</i>
     */
    Pointer ydoc_collection_id(YrsDoc doc);

    /**
     * Returns status of should_load flag of this [YDocImpl] instance, informing parent [YDocImpl] if this
     * <br>
     * document instance requested a data load.<br>
     * Original signature : <code>uint8_t ydoc_should_load(YrsDoc*)</code><br>
     * <i>native declaration : libyrs.h:793</i>
     */
    byte ydoc_should_load(YrsDoc doc);

    /**
     * Returns status of auto_load flag of this [YDocImpl] instance. Auto loaded sub-documents automatically
     * <br>
     * send a load request to their parent documents.<br>
     * Original signature : <code>uint8_t ydoc_auto_load(YrsDoc*)</code><br>
     * <i>native declaration : libyrs.h:799</i>
     */
    byte ydoc_auto_load(YrsDoc doc);

    /**
     * Original signature : <code>YrsSubscription* ydoc_observe_updates_v1(YrsDoc*, void*, ydoc_observe_updates_v1_cb_callback*)</code><br>
     * <i>native declaration : libyrs.h:801</i>
     */
    YrsSubscription ydoc_observe_updates_v1(YrsDoc doc, Pointer state, ydoc_observe_updates_v1_cb_callback cb);

    /**
     * Original signature : <code>YrsSubscription* ydoc_observe_updates_v2(YrsDoc*, void*, ydoc_observe_updates_v2_cb_callback*)</code><br>
     * <i>native declaration : libyrs.h:803</i>
     */
    YrsSubscription ydoc_observe_updates_v2(YrsDoc doc, Pointer state, ydoc_observe_updates_v2_cb_callback cb);

    /**
     * Original signature : <code>YrsSubscription* ydoc_observe_after_transaction(YrsDoc*, void*, ydoc_observe_after_transaction_cb_callback*)</code><br>
     * <i>native declaration : libyrs.h:805</i>
     */
    YrsSubscription ydoc_observe_after_transaction(YrsDoc doc, Pointer state, ydoc_observe_after_transaction_cb_callback cb);

    /**
     * Original signature : <code>YrsSubscription* ydoc_observe_subdocs(YrsDoc*, void*, ydoc_observe_subdocs_cb_callback*)</code><br>
     * <i>native declaration : libyrs.h:807</i>
     */
    YrsSubscription ydoc_observe_subdocs(YrsDoc doc, Pointer state, ydoc_observe_subdocs_cb_callback cb);

    /**
     * Original signature : <code>YrsSubscription* ydoc_observe_clear(YrsDoc*, void*, ydoc_observe_clear_cb_callback*)</code><br>
     * <i>native declaration : libyrs.h:809</i>
     */
    YrsSubscription ydoc_observe_clear(YrsDoc doc, Pointer state, ydoc_observe_clear_cb_callback cb);

    /**
     * Manually send a load request to a parent document of this subdoc.<br>
     * Original signature : <code>void ydoc_load(YrsDoc*, YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:814</i>
     */
    void ydoc_load(YrsDoc doc, YrsTransaction parent_txn);

    /**
     * Destroys current document, sending a 'destroy' event and clearing up all the event callbacks
     * <br>
     * registered.<br>
     * Original signature : <code>void ydoc_clear(YrsDoc*, YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:820</i>
     */
    void ydoc_clear(YrsDoc doc, YrsTransaction parent_txn);

    /**
     * Starts a new read-only transaction on a given document. All other operations happen in context
     * <br>
     * of a transaction. Yrs transactions do not follow ACID rules. Once a set of operations is
     * <br>
     * complete, a transaction can be finished using `ytransaction_commit` function.
     * <br>
     * <br>
     * Returns `NULL` if read-only transaction couldn't be created, i.e. when another read-write
     * <br>
     * transaction is already opened.<br>
     * Original signature : <code>YrsTransaction* ydoc_read_transaction(YrsDoc*)</code><br>
     * <i>native declaration : libyrs.h:830</i>
     */
    YrsTransaction ydoc_read_transaction(YrsDoc doc);

    /**
     * Starts a new read-write transaction on a given document. All other operations happen in context
     * <br>
     * of a transaction. Yrs transactions do not follow ACID rules. Once a set of operations is
     * <br>
     * complete, a transaction can be finished using `ytransaction_commit` function.
     * <br>
     * <br>
     * `origin_len` and `origin` are optional parameters to specify a byte sequence used to mark
     * <br>
     * the origin of this transaction (eg. you may decide to give different origins for transaction
     * <br>
     * applying remote updates). These can be used by event handlers or `YrsUndoManager` to perform
     * <br>
     * specific actions. If origin should not be set, call `ydoc_write_transaction(doc, 0, NULL)`.
     * <br>
     * <br>
     * Returns `NULL` if read-write transaction couldn't be created, i.e. when another transaction is
     * <br>
     * already opened.<br>
     * Original signature : <code>YrsTransaction* ydoc_write_transaction(YrsDoc*, uint32_t, const char*)</code><br>
     * <i>native declaration : libyrs.h:845</i>
     */
    YrsTransaction ydoc_write_transaction(YrsDoc doc, int origin_len, String origin);


    /**
     * Returns a list of subdocs existing within current document.<br>
     * Original signature : <code>YrsDoc** ytransaction_subdocs(YrsTransaction*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:850</i>
     */
    YrsDoc.ByReference[] ytransaction_subdocs(YrsTransaction txn, IntBuffer len);

    /**
     * Returns a list of subdocs existing within current document.<br>
     * Original signature : <code>YrsDoc** ytransaction_subdocs(YrsTransaction*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:850</i>
     */
    YrsDoc.ByReference[] ytransaction_subdocs(YrsTransaction txn, IntByReference len);

    /**
     * Commit and dispose provided read-write transaction. This operation releases allocated resources,
     * <br>
     * triggers update events and performs a storage compression over all operations executed in scope
     * <br>
     * of a current transaction.<br>
     * Original signature : <code>void ytransaction_commit(YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:857</i>
     */
    void ytransaction_commit(YrsTransaction txn);

    /**
     * Returns `1` if current transaction is of read-write type.
     * <br>
     * Returns `0` if transaction is read-only.<br>
     * Original signature : <code>uint8_t ytransaction_writeable(YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:863</i>
     */
    byte ytransaction_writeable(YrsTransaction txn);

    /**
     * Gets a reference to shared data type instance at the document root-level,
     * <br>
     * identified by its `name`, which must be a null-terminated UTF-8 compatible string.
     * <br>
     * <br>
     * Returns `NULL` if no such structure was defined in the document before.<br>
     * Original signature : <code>YrsBranch* ytype_get(YrsTransaction*, const char*)</code><br>
     * <i>native declaration : libyrs.h:871</i>
     */
    YrsBranch ytype_get(YrsTransaction txn, String name);

    /**
     * Gets a reference to shared data type instance at the document root-level,
     * <br>
     * identified by its `name`, which must be a null-terminated UTF-8 compatible string.
     * <br>
     * <br>
     * Returns `NULL` if no such structure was defined in the document before.<br>
     * Original signature : <code>YrsBranch* ytype_get(YrsTransaction*, const char*)</code><br>
     * <i>native declaration : libyrs.h:871</i>
     */
    YrsBranch ytype_get(YrsTransaction txn, Pointer name);

    /**
     * Gets or creates a new shared `YText` data type instance as a root-level type of a given document.
     * <br>
     * This structure can later be accessed using its `name`, which must be a null-terminated UTF-8
     * <br>
     * compatible string.<br>
     * Original signature : <code>YrsBranch* ytext(YrsDoc*, const char*)</code><br>
     * <i>native declaration : libyrs.h:878</i>
     */
    YrsBranch ytext(YrsDoc doc, String name);

    /**
     * Gets or creates a new shared `YArray` data type instance as a root-level type of a given document.
     * <br>
     * This structure can later be accessed using its `name`, which must be a null-terminated UTF-8
     * <br>
     * compatible string.
     * <br>
     * <br>
     * Use [yarray_destroy] in order to release pointer returned that way - keep in mind that this will
     * <br>
     * not remove `YArray` instance from the document itself (once created it'll last for the entire
     * <br>
     * lifecycle of a document).<br>
     * Original signature : <code>YrsBranch* yarray(YrsDoc*, const char*)</code><br>
     * <i>native declaration : libyrs.h:889</i>
     */
    YrsBranch yarray(YrsDoc doc, String name);

    /**
     * Gets or creates a new shared `YMap` data type instance as a root-level type of a given document.
     * <br>
     * This structure can later be accessed using its `name`, which must be a null-terminated UTF-8
     * <br>
     * compatible string.
     * <br>
     * <br>
     * Use [ymap_destroy] in order to release pointer returned that way - keep in mind that this will
     * <br>
     * not remove `YMap` instance from the document itself (once created it'll last for the entire
     * <br>
     * lifecycle of a document).<br>
     * Original signature : <code>YrsBranch* ymap(YrsDoc*, const char*)</code><br>
     * <i>native declaration : libyrs.h:900</i>
     */
    YrsBranch ymap(YrsDoc doc, String name);

    /**
     * Gets or creates a new shared `YXmlElement` data type instance as a root-level type of a given
     * <br>
     * document. This structure can later be accessed using its `name`, which must be a null-terminated
     * <br>
     * UTF-8 compatible string.<br>
     * Original signature : <code>YrsBranch* yxmlfragment(YrsDoc*, const char*)</code><br>
     * <i>native declaration : libyrs.h:907</i>
     */
    YrsBranch yxmlfragment(YrsDoc doc, String name);

    /**
     * Returns a state vector of a current transaction's document, serialized using lib0 version 1
     * <br>
     * encoding. Payload created by this function can then be send over the network to a remote peer,
     * <br>
     * where it can be used as a parameter of [ytransaction_state_diff_v1] in order to produce a delta
     * <br>
     * update payload, that can be send back and applied locally in order to efficiently propagate
     * <br>
     * updates from one peer to another.
     * <br>
     * <br>
     * The length of a generated binary will be passed within a `len` out parameter.
     * <br>
     * <br>
     * Once no longer needed, a returned binary can be disposed using [ybinary_destroy] function.<br>
     * Original signature : <code>char* ytransaction_state_vector_v1(const YrsTransaction*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:920</i>
     */
    Pointer ytransaction_state_vector_v1(YrsTransaction txn, IntBuffer len);

    /**
     * Returns a state vector of a current transaction's document, serialized using lib0 version 1
     * <br>
     * encoding. Payload created by this function can then be send over the network to a remote peer,
     * <br>
     * where it can be used as a parameter of [ytransaction_state_diff_v1] in order to produce a delta
     * <br>
     * update payload, that can be send back and applied locally in order to efficiently propagate
     * <br>
     * updates from one peer to another.
     * <br>
     * <br>
     * The length of a generated binary will be passed within a `len` out parameter.
     * <br>
     * <br>
     * Once no longer needed, a returned binary can be disposed using [ybinary_destroy] function.<br>
     * Original signature : <code>char* ytransaction_state_vector_v1(const YrsTransaction*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:920</i>
     */
    Pointer ytransaction_state_vector_v1(YrsTransaction txn, IntByReference len);

    /**
     * Returns a delta difference between current state of a transaction's document and a state vector
     * <br>
     * `sv` encoded as a binary payload using lib0 version 1 encoding (which could be generated using
     * <br>
     * [ytransaction_state_vector_v1]). Such delta can be send back to the state vector's sender in
     * <br>
     * order to propagate and apply (using [ytransaction_apply]) all updates known to a current
     * <br>
     * document, which remote peer was not aware of.
     * <br>
     * <br>
     * If passed `sv` pointer is null, the generated diff will be a snapshot containing entire state of
     * <br>
     * the document.
     * <br>
     * <br>
     * A length of an encoded state vector payload must be passed as `sv_len` parameter.
     * <br>
     * <br>
     * A length of generated delta diff binary will be passed within a `len` out parameter.
     * <br>
     * <br>
     * Once no longer needed, a returned binary can be disposed using [ybinary_destroy] function.<br>
     * Original signature : <code>char* ytransaction_state_diff_v1(const YrsTransaction*, const char*, uint32_t, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:938</i>
     */
    Pointer ytransaction_state_diff_v1(YrsTransaction txn, String sv, int sv_len, IntBuffer len);

    /**
     * Returns a delta difference between current state of a transaction's document and a state vector
     * <br>
     * `sv` encoded as a binary payload using lib0 version 1 encoding (which could be generated using
     * <br>
     * [ytransaction_state_vector_v1]). Such delta can be send back to the state vector's sender in
     * <br>
     * order to propagate and apply (using [ytransaction_apply]) all updates known to a current
     * <br>
     * document, which remote peer was not aware of.
     * <br>
     * <br>
     * If passed `sv` pointer is null, the generated diff will be a snapshot containing entire state of
     * <br>
     * the document.
     * <br>
     * <br>
     * A length of an encoded state vector payload must be passed as `sv_len` parameter.
     * <br>
     * <br>
     * A length of generated delta diff binary will be passed within a `len` out parameter.
     * <br>
     * <br>
     * Once no longer needed, a returned binary can be disposed using [ybinary_destroy] function.<br>
     * Original signature : <code>char* ytransaction_state_diff_v1(const YrsTransaction*, const char*, uint32_t, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:938</i>
     */
    Pointer ytransaction_state_diff_v1(YrsTransaction txn, byte[] sv, int sv_len, IntByReference len);

    /**
     * Returns a delta difference between current state of a transaction's document and a state vector
     * <br>
     * `sv` encoded as a binary payload using lib0 version 1 encoding (which could be generated using
     * <br>
     * [ytransaction_state_vector_v1]). Such delta can be send back to the state vector's sender in
     * <br>
     * order to propagate and apply (using [ytransaction_apply_v2]) all updates known to a current
     * <br>
     * document, which remote peer was not aware of.
     * <br>
     * <br>
     * If passed `sv` pointer is null, the generated diff will be a snapshot containing entire state of
     * <br>
     * the document.
     * <br>
     * <br>
     * A length of an encoded state vector payload must be passed as `sv_len` parameter.
     * <br>
     * <br>
     * A length of generated delta diff binary will be passed within a `len` out parameter.
     * <br>
     * <br>
     * Once no longer needed, a returned binary can be disposed using [ybinary_destroy] function.<br>
     * Original signature : <code>char* ytransaction_state_diff_v2(const YrsTransaction*, const char*, uint32_t, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:956</i>
     */
    Pointer ytransaction_state_diff_v2(YrsTransaction txn, String sv, int sv_len, IntBuffer len);

    /**
     * Returns a delta difference between current state of a transaction's document and a state vector
     * <br>
     * `sv` encoded as a binary payload using lib0 version 1 encoding (which could be generated using
     * <br>
     * [ytransaction_state_vector_v1]). Such delta can be send back to the state vector's sender in
     * <br>
     * order to propagate and apply (using [ytransaction_apply_v2]) all updates known to a current
     * <br>
     * document, which remote peer was not aware of.
     * <br>
     * <br>
     * If passed `sv` pointer is null, the generated diff will be a snapshot containing entire state of
     * <br>
     * the document.
     * <br>
     * <br>
     * A length of an encoded state vector payload must be passed as `sv_len` parameter.
     * <br>
     * <br>
     * A length of generated delta diff binary will be passed within a `len` out parameter.
     * <br>
     * <br>
     * Once no longer needed, a returned binary can be disposed using [ybinary_destroy] function.<br>
     * Original signature : <code>char* ytransaction_state_diff_v2(const YrsTransaction*, const char*, uint32_t, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:956</i>
     */
    Pointer ytransaction_state_diff_v2(YrsTransaction txn, byte[] sv, int sv_len, IntByReference len);

    /**
     * Returns a snapshot descriptor of a current state of the document. This snapshot information
     * <br>
     * can be then used to encode document data at a particular point in time
     * <br>
     * (see: `ytransaction_encode_state_from_snapshot`).<br>
     * Original signature : <code>char* ytransaction_snapshot(const YrsTransaction*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:963</i>
     */
    Pointer ytransaction_snapshot(YrsTransaction txn, IntBuffer len);

    /**
     * Returns a snapshot descriptor of a current state of the document. This snapshot information
     * <br>
     * can be then used to encode document data at a particular point in time
     * <br>
     * (see: `ytransaction_encode_state_from_snapshot`).<br>
     * Original signature : <code>char* ytransaction_snapshot(const YrsTransaction*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:963</i>
     */
    Pointer ytransaction_snapshot(YrsTransaction txn, IntByReference len);

    /**
     * Encodes a state of the document at a point in time specified by the provided `snapshot`
     * <br>
     * (generated by: `ytransaction_snapshot`). This is useful to generate a past view of the document.
     * <br>
     * <br>
     * The returned update is binary compatible with Yrs update lib0 v1 encoding, and can be processed
     * <br>
     * with functions dedicated to work on it, like `ytransaction_apply`.
     * <br>
     * <br>
     * This function requires document with a GC option flag turned off (otherwise "time travel" would
     * <br>
     * not be a safe operation). If this is not a case, the NULL pointer will be returned.<br>
     * Original signature : <code>char* ytransaction_encode_state_from_snapshot_v1(const YrsTransaction*, const char*, uint32_t, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:975</i>
     */
    Pointer ytransaction_encode_state_from_snapshot_v1(YrsTransaction txn, String snapshot, int snapshot_len, IntBuffer len);

    /**
     * Encodes a state of the document at a point in time specified by the provided `snapshot`
     * <br>
     * (generated by: `ytransaction_snapshot`). This is useful to generate a past view of the document.
     * <br>
     * <br>
     * The returned update is binary compatible with Yrs update lib0 v1 encoding, and can be processed
     * <br>
     * with functions dedicated to work on it, like `ytransaction_apply`.
     * <br>
     * <br>
     * This function requires document with a GC option flag turned off (otherwise "time travel" would
     * <br>
     * not be a safe operation). If this is not a case, the NULL pointer will be returned.<br>
     * Original signature : <code>char* ytransaction_encode_state_from_snapshot_v1(const YrsTransaction*, const char*, uint32_t, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:975</i>
     */
    Pointer ytransaction_encode_state_from_snapshot_v1(YrsTransaction txn, byte[] snapshot, int snapshot_len, IntByReference len);

    /**
     * Encodes a state of the document at a point in time specified by the provided `snapshot`
     * <br>
     * (generated by: `ytransaction_snapshot`). This is useful to generate a past view of the document.
     * <br>
     * <br>
     * The returned update is binary compatible with Yrs update lib0 v2 encoding, and can be processed
     * <br>
     * with functions dedicated to work on it, like `ytransaction_apply_v2`.
     * <br>
     * <br>
     * This function requires document with a GC option flag turned off (otherwise "time travel" would
     * <br>
     * not be a safe operation). If this is not a case, the NULL pointer will be returned.<br>
     * Original signature : <code>char* ytransaction_encode_state_from_snapshot_v2(const YrsTransaction*, const char*, uint32_t, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:987</i>
     */
    Pointer ytransaction_encode_state_from_snapshot_v2(YrsTransaction txn, String snapshot, int snapshot_len, IntBuffer len);

    /**
     * Encodes a state of the document at a point in time specified by the provided `snapshot`
     * <br>
     * (generated by: `ytransaction_snapshot`). This is useful to generate a past view of the document.
     * <br>
     * <br>
     * The returned update is binary compatible with Yrs update lib0 v2 encoding, and can be processed
     * <br>
     * with functions dedicated to work on it, like `ytransaction_apply_v2`.
     * <br>
     * <br>
     * This function requires document with a GC option flag turned off (otherwise "time travel" would
     * <br>
     * not be a safe operation). If this is not a case, the NULL pointer will be returned.<br>
     * Original signature : <code>char* ytransaction_encode_state_from_snapshot_v2(const YrsTransaction*, const char*, uint32_t, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:987</i>
     */
    Pointer ytransaction_encode_state_from_snapshot_v2(YrsTransaction txn, byte[] snapshot, int snapshot_len, IntByReference len);

    /**
     * Returns an unapplied Delete Set for the current document, waiting for missing updates in order
     * <br>
     * to be integrated into document store.
     * <br>
     * <br>
     * Return `NULL` if there's no missing delete set and all deletions have been applied.
     * <br>
     * See also: `ytransaction_pending_update`<br>
     * Original signature : <code>YrsDeleteSet* ytransaction_pending_ds(const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:996</i>
     */
    YrsDeleteSet ytransaction_pending_ds(YrsTransaction txn);

    /**
     * Original signature : <code>void ydelete_set_destroy(YrsDeleteSet*)</code><br>
     * <i>native declaration : libyrs.h:998</i>
     */
    void ydelete_set_destroy(YrsDeleteSet ds);

    /**
     * Returns a pending update associated with an underlying `YrsDoc`. Pending update contains update
     * <br>
     * data waiting for being integrated into main document store. Usually reason for that is that
     * <br>
     * there were missing updates required for integration. In such cases they need to arrive and be
     * <br>
     * integrated first.
     * <br>
     * <br>
     * Returns `NULL` if there is not update pending. Returned value can be released by calling
     * <br>
     * `ypending_update_destroy`.
     * <br>
     * See also: `ytransaction_pending_ds`<br>
     * Original signature : <code>YrsPendingUpdate* ytransaction_pending_update(const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:1010</i>
     */
    YrsPendingUpdate ytransaction_pending_update(YrsTransaction txn);

    /**
     * Original signature : <code>void ypending_update_destroy(YrsPendingUpdate*)</code><br>
     * <i>native declaration : libyrs.h:1012</i>
     */
    void ypending_update_destroy(YrsPendingUpdate update);

    /**
     * Returns a null-terminated UTF-8 encoded string representation of an `update` binary payload,
     * <br>
     * encoded using lib0 v1 encoding.
     * <br>
     * Returns null if update couldn't be parsed into a lib0 v1 formatting.<br>
     * Original signature : <code>char* yupdate_debug_v1(const char*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1019</i>
     */
    Pointer yupdate_debug_v1(Pointer update, int update_len);

    /**
     * Returns a null-terminated UTF-8 encoded string representation of an `update` binary payload,
     * <br>
     * encoded using lib0 v2 encoding.
     * <br>
     * Returns null if update couldn't be parsed into a lib0 v2 formatting.<br>
     * Original signature : <code>char* yupdate_debug_v2(const char*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1026</i>
     */
    Pointer yupdate_debug_v2(Pointer update, int update_len);

    /**
     * Applies an diff update (generated by `ytransaction_state_diff_v1`) to a local transaction's
     * <br>
     * document.
     * <br>
     * <br>
     * A length of generated `diff` binary must be passed within a `diff_len` out parameter.
     * <br>
     * <br>
     * Returns an error code in case if transaction succeeded failed:
     * <br>
     * - **0**: success
     * <br>
     * - `ERR_CODE_IO` (**1**): couldn't read data from input stream.
     * <br>
     * - `ERR_CODE_VAR_INT` (**2**): decoded variable integer outside of the expected integer size bounds.
     * <br>
     * - `ERR_CODE_EOS` (**3**): end of stream found when more data was expected.
     * <br>
     * - `ERR_CODE_UNEXPECTED_VALUE` (**4**): decoded enum tag value was not among known cases.
     * <br>
     * - `ERR_CODE_INVALID_JSON` (**5**): failure when trying to decode JSON content.
     * <br>
     * - `ERR_CODE_OTHER` (**6**): other error type than the one specified.<br>
     * Original signature : <code>uint8_t ytransaction_apply(YrsTransaction*, const char*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1043</i>
     */
    byte ytransaction_apply(YrsTransaction txn, byte[] diff, int diff_len);

    /**
     * Applies a diff update (generated by [ytransaction_state_diff_v2]) to a local transaction's
     * <br>
     * document.
     * <br>
     * <br>
     * A length of generated `diff` binary must be passed within a `diff_len` out parameter.
     * <br>
     * <br>
     * Returns an error code in case if transaction succeeded failed:
     * <br>
     * - **0**: success
     * <br>
     * - `ERR_CODE_IO` (**1**): couldn't read data from input stream.
     * <br>
     * - `ERR_CODE_VAR_INT` (**2**): decoded variable integer outside of the expected integer size bounds.
     * <br>
     * - `ERR_CODE_EOS` (**3**): end of stream found when more data was expected.
     * <br>
     * - `ERR_CODE_UNEXPECTED_VALUE` (**4**): decoded enum tag value was not among known cases.
     * <br>
     * - `ERR_CODE_INVALID_JSON` (**5**): failure when trying to decode JSON content.
     * <br>
     * - `ERR_CODE_OTHER` (**6**): other error type than the one specified.<br>
     * Original signature : <code>uint8_t ytransaction_apply_v2(YrsTransaction*, const char*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1060</i>
     */
    byte ytransaction_apply_v2(YrsTransaction txn, byte[] diff, int diff_len);

    /**
     * Returns the length of the `YText` string content in bytes (without the null terminator character)<br>
     * Original signature : <code>uint32_t ytext_len(const YrsBranch*, const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:1065</i>
     */
    int ytext_len(YrsBranch txt, YrsTransaction txn);

    /**
     * Returns a null-terminated UTF-8 encoded string content of a current `YText` shared data type.
     * <br>
     * <br>
     * Generated string resources should be released using [ystring_destroy] function.<br>
     * Original signature : <code>char* ytext_string(const YrsBranch*, const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:1072</i>
     */
    Pointer ytext_string(YrsBranch txt, YrsTransaction txn);

    /**
     * Inserts a null-terminated UTF-8 encoded string a given `index`. `index` value must be between
     * <br>
     * 0 and a length of a `YText` (inclusive, accordingly to [ytext_len] return value), otherwise this
     * <br>
     * function will panic.
     * <br>
     * <br>
     * A `str` parameter must be a null-terminated UTF-8 encoded string. This function doesn't take
     * <br>
     * ownership over a passed value - it will be copied and therefore a string parameter must be
     * <br>
     * released by the caller.
     * <br>
     * <br>
     * A nullable pointer with defined `attrs` will be used to wrap provided text with
     * <br>
     * a formatting blocks. `attrs` must be a map-like type.<br>
     * Original signature : <code>void ytext_insert(const YrsBranch*, YrsTransaction*, uint32_t, const char*, YrsInput*)</code><br>
     * <i>native declaration : libyrs.h:1086</i>
     */
    void ytext_insert(YrsBranch txt, YrsTransaction txn, int index, String value, YrsInput attrs);

    /**
     * Inserts a null-terminated UTF-8 encoded string a given `index`. `index` value must be between
     * <br>
     * 0 and a length of a `YText` (inclusive, accordingly to [ytext_len] return value), otherwise this
     * <br>
     * function will panic.
     * <br>
     * <br>
     * A `str` parameter must be a null-terminated UTF-8 encoded string. This function doesn't take
     * <br>
     * ownership over a passed value - it will be copied and therefore a string parameter must be
     * <br>
     * released by the caller.
     * <br>
     * <br>
     * A nullable pointer with defined `attrs` will be used to wrap provided text with
     * <br>
     * a formatting blocks. `attrs` must be a map-like type.<br>
     * Original signature : <code>void ytext_insert(const YrsBranch*, YrsTransaction*, uint32_t, const char*, YrsInput*)</code><br>
     * <i>native declaration : libyrs.h:1086</i>
     */
    void ytext_insert(YrsBranch txt, YrsTransaction txn, int index, Pointer value, YrsInput attrs);

    /**
     * Wraps an existing piece of text within a range described by `index`-`len` parameters with
     * <br>
     * formatting blocks containing provided `attrs` metadata. `attrs` must be a map-like type.<br>
     * Original signature : <code>void ytext_format(const YrsBranch*, YrsTransaction*, uint32_t, uint32_t, YrsInput*)</code><br>
     * <i>native declaration : libyrs.h:1092</i>
     */
    void ytext_format(YrsBranch txt, YrsTransaction txn, int index, int len, YrsInput attrs);

    /**
     * Inserts an embed content given `index`. `index` value must be between 0 and a length of a
     * <br>
     * `YText` (inclusive, accordingly to [ytext_len] return value), otherwise this
     * <br>
     * function will panic.
     * <br>
     * <br>
     * A `str` parameter must be a null-terminated UTF-8 encoded string. This function doesn't take
     * <br>
     * ownership over a passed value - it will be copied and therefore a string parameter must be
     * <br>
     * released by the caller.
     * <br>
     * <br>
     * A nullable pointer with defined `attrs` will be used to wrap provided text with
     * <br>
     * a formatting blocks. `attrs` must be a map-like type.<br>
     * Original signature : <code>void ytext_insert_embed(const YrsBranch*, YrsTransaction*, uint32_t, YrsInput*, YrsInput*)</code><br>
     * <i>native declaration : libyrs.h:1106</i>
     */
    void ytext_insert_embed(YrsBranch txt, YrsTransaction txn, int index, YrsInput content, YrsInput attrs);

    /**
     * Removes a range of characters, starting a a given `index`. This range must fit within the bounds
     * <br>
     * of a current `YText`, otherwise this function call will fail.
     * <br>
     * <br>
     * An `index` value must be between 0 and the length of a `YText` (exclusive, accordingly to
     * <br>
     * [ytext_len] return value).
     * <br>
     * <br>
     * A `length` must be lower or equal number of characters (counted as UTF chars depending on the
     * <br>
     * encoding configured by `YrsDoc`) from `index` position to the end of of the string.<br>
     * Original signature : <code>void ytext_remove_range(const YrsBranch*, YrsTransaction*, uint32_t, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1118</i>
     */
    void ytext_remove_range(YrsBranch txt, YrsTransaction txn, int index, int length);

    /**
     * Returns a number of elements stored within current instance of `YArray`.<br>
     * Original signature : <code>uint32_t yarray_len(const YrsBranch*)</code><br>
     * <i>native declaration : libyrs.h:1123</i>
     */
    int yarray_len(YrsBranch array);

    /**
     * Returns a pointer to a `YrsOutput` value stored at a given `index` of a current `YArray`.
     * <br>
     * If `index` is outside of the bounds of an array, a null pointer will be returned.
     * <br>
     * <br>
     * A value returned should be eventually released using [youtput_destroy] function.<br>
     * Original signature : <code>YrsOutput* yarray_get(const YrsBranch*, const YrsTransaction*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1131</i>
     */
    YrsOutput yarray_get(YrsBranch array, YrsTransaction txn, int index);

    /**
     * Inserts a range of `items` into current `YArray`, starting at given `index`. An `items_len`
     * <br>
     * parameter is used to determine the size of `items` array - it can also be used to insert
     * <br>
     * a single element given its pointer.
     * <br>
     * <br>
     * An `index` value must be between 0 and (inclusive) length of a current array (use [yarray_len]
     * <br>
     * to determine its length), otherwise it will panic at runtime.
     * <br>
     * <br>
     * `YArray` doesn't take ownership over the inserted `items` data - their contents are being copied
     * <br>
     * into array structure - therefore caller is responsible for freeing all memory associated with
     * <br>
     * input params.<br>
     * Original signature : <code>void yarray_insert_range(const YrsBranch*, YrsTransaction*, uint32_t, YrsInput*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1145</i>
     */
    void yarray_insert_range(YrsBranch array, YrsTransaction txn, int index, YrsInput[] items, int items_len);

    /**
     * Removes a `len` of consecutive range of elements from current `array` instance, starting at
     * <br>
     * a given `index`. Range determined by `index` and `len` must fit into boundaries of an array,
     * <br>
     * otherwise it will panic at runtime.<br>
     * Original signature : <code>void yarray_remove_range(const YrsBranch*, YrsTransaction*, uint32_t, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1152</i>
     */
    void yarray_remove_range(YrsBranch array, YrsTransaction txn, int index, int len);

    /**
     * Original signature : <code>void yarray_move(const YrsBranch*, YrsTransaction*, uint32_t, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1154</i>
     */
    void yarray_move(YrsBranch array, YrsTransaction txn, int source, int target);

    /**
     * Returns an iterator, which can be used to traverse over all elements of an `array` (`array`'s
     * <br>
     * length can be determined using [yarray_len] function).
     * <br>
     * <br>
     * Use [yarray_iter_next] function in order to retrieve a consecutive array elements.
     * <br>
     * Use [yarray_iter_destroy] function in order to close the iterator and release its resources.<br>
     * Original signature : <code>YrsArrayIter* yarray_iter(const YrsBranch*, YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:1163</i>
     */
    YrsArrayIter yarray_iter(YrsBranch array, YrsTransaction txn);

    /**
     * Releases all of an `YArray` iterator resources created by calling [yarray_iter].<br>
     * Original signature : <code>void yarray_iter_destroy(YrsArrayIter*)</code><br>
     * <i>native declaration : libyrs.h:1168</i>
     */
    void yarray_iter_destroy(YrsArrayIter iter);

    /**
     * Moves current `YArray` iterator over to a next element, returning a pointer to it. If an iterator
     * <br>
     * comes to an end of an array, a null pointer will be returned.
     * <br>
     * <br>
     * Returned values should be eventually released using [youtput_destroy] function.<br>
     * Original signature : <code>YrsOutput* yarray_iter_next(YrsArrayIter*)</code><br>
     * <i>native declaration : libyrs.h:1176</i>
     */
    YrsOutput yarray_iter_next(YrsArrayIter iterator);

    /**
     * Returns an iterator, which can be used to traverse over all key-value pairs of a `map`.
     * <br>
     * <br>
     * Use [ymap_iter_next] function in order to retrieve a consecutive (**unordered**) map entries.
     * <br>
     * Use [ymap_iter_destroy] function in order to close the iterator and release its resources.<br>
     * Original signature : <code>YrsMapIter* ymap_iter(const YrsBranch*, const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:1184</i>
     */
    YrsMapIter ymap_iter(YrsBranch map, YrsTransaction txn);

    /**
     * Releases all of an `YMap` iterator resources created by calling [ymap_iter].<br>
     * Original signature : <code>void ymap_iter_destroy(YrsMapIter*)</code><br>
     * <i>native declaration : libyrs.h:1189</i>
     */
    void ymap_iter_destroy(YrsMapIter iter);

    /**
     * Moves current `YMap` iterator over to a next entry, returning a pointer to it. If an iterator
     * <br>
     * comes to an end of a map, a null pointer will be returned. Yrs maps are unordered and so are
     * <br>
     * their iterators.
     * <br>
     * <br>
     * Returned values should be eventually released using [ymap_entry_destroy] function.<br>
     * Original signature : <code>YrsMapEntry* ymap_iter_next(YrsMapIter*)</code><br>
     * <i>native declaration : libyrs.h:1198</i>
     */
    YrsMapEntry ymap_iter_next(YrsMapIter iter);

    /**
     * Returns a number of entries stored within a `map`.<br>
     * Original signature : <code>uint32_t ymap_len(const YrsBranch*, const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:1203</i>
     */
    int ymap_len(YrsBranch map, YrsTransaction txn);

    /**
     * Inserts a new entry (specified as `key`-`value` pair) into a current `map`. If entry under such
     * <br>
     * given `key` already existed, its corresponding value will be replaced.
     * <br>
     * <br>
     * A `key` must be a null-terminated UTF-8 encoded string, which contents will be copied into
     * <br>
     * a `map` (therefore it must be freed by the function caller).
     * <br>
     * <br>
     * A `value` content is being copied into a `map`, therefore any of its content must be freed by
     * <br>
     * the function caller.<br>
     * Original signature : <code>void ymap_insert(const YrsBranch*, YrsTransaction*, const char*, YrsInput*)</code><br>
     * <i>native declaration : libyrs.h:1215</i>
     */
    void ymap_insert(YrsBranch map, YrsTransaction txn, String key, YrsInput value);

    /**
     * Removes a `map` entry, given its `key`. Returns `1` if the corresponding entry was successfully
     * <br>
     * removed or `0` if no entry with a provided `key` has been found inside of a `map`.
     * <br>
     * <br>
     * A `key` must be a null-terminated UTF-8 encoded string.<br>
     * Original signature : <code>uint8_t ymap_remove(const YrsBranch*, YrsTransaction*, const char*)</code><br>
     * <i>native declaration : libyrs.h:1223</i>
     */
    byte ymap_remove(YrsBranch map, YrsTransaction txn, String key);

    /**
     * Returns a value stored under the provided `key`, or a null pointer if no entry with such `key`
     * <br>
     * has been found in a current `map`. A returned value is allocated by this function and therefore
     * <br>
     * should be eventually released using [youtput_destroy] function.
     * <br>
     * <br>
     * A `key` must be a null-terminated UTF-8 encoded string.<br>
     * Original signature : <code>YrsOutput* ymap_get(const YrsBranch*, const YrsTransaction*, const char*)</code><br>
     * <i>native declaration : libyrs.h:1232</i>
     */
    YrsOutput ymap_get(YrsBranch map, YrsTransaction txn, String key);

    /**
     * Removes all entries from a current `map`.<br>
     * Original signature : <code>void ymap_remove_all(const YrsBranch*, YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:1237</i>
     */
    void ymap_remove_all(YrsBranch map, YrsTransaction txn);

    /**
     * Return a name (or an XML tag) of a current `YXmlElement`. Root-level XML nodes use "UNDEFINED" as
     * <br>
     * their tag names.
     * <br>
     * <br>
     * Returned value is a null-terminated UTF-8 string, which must be released using [ystring_destroy]
     * <br>
     * function.<br>
     * Original signature : <code>char* yxmlelem_tag(const YrsBranch*)</code><br>
     * <i>native declaration : libyrs.h:1246</i>
     */
    Pointer yxmlelem_tag(YrsBranch xml);

    /**
     * Converts current `YXmlElement` together with its children and attributes into a flat string
     * <br>
     * representation (no padding) eg. `<UNDEFINED><title key="value">sample text</title></UNDEFINED>`.
     * <br>
     * <br>
     * Returned value is a null-terminated UTF-8 string, which must be released using [ystring_destroy]
     * <br>
     * function.<br>
     * Original signature : <code>char* yxmlelem_string(const YrsBranch*, const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:1255</i>
     */
    Pointer yxmlelem_string(YrsBranch xml, YrsTransaction txn);

    /**
     * Inserts an XML attribute described using `attr_name` and `attr_value`. If another attribute with
     * <br>
     * the same name already existed, its value will be replaced with a provided one.
     * <br>
     * <br>
     * Both `attr_name` and `attr_value` must be a null-terminated UTF-8 encoded strings. Their
     * <br>
     * contents are being copied, therefore it's up to a function caller to properly release them.<br>
     * Original signature : <code>void yxmlelem_insert_attr(const YrsBranch*, YrsTransaction*, const char*, const char*)</code><br>
     * <i>native declaration : libyrs.h:1264</i>
     */
    void yxmlelem_insert_attr(YrsBranch xml, YrsTransaction txn, String attr_name, String attr_value);

    /**
     * Removes an attribute from a current `YXmlElement`, given its name.
     * <br>
     * <br>
     * An `attr_name`must be a null-terminated UTF-8 encoded string.<br>
     * Original signature : <code>void yxmlelem_remove_attr(const YrsBranch*, YrsTransaction*, const char*)</code><br>
     * <i>native declaration : libyrs.h:1271</i>
     */
    void yxmlelem_remove_attr(YrsBranch xml, YrsTransaction txn, String attr_name);


    /**
     * Returns the value of a current `YXmlElement`, given its name, or a null pointer if not attribute
     * <br>
     * with such name has been found. Returned pointer is a null-terminated UTF-8 encoded string, which
     * <br>
     * should be released using [ystring_destroy] function.
     * <br>
     * <br>
     * An `attr_name` must be a null-terminated UTF-8 encoded string.<br>
     * Original signature : <code>char* yxmlelem_get_attr(const YrsBranch*, const YrsTransaction*, const char*)</code><br>
     * <i>native declaration : libyrs.h:1280</i>
     */
    Pointer yxmlelem_get_attr(YrsBranch xml, YrsTransaction txn, String attr_name);

    /**
     * Returns an iterator over the `YXmlElement` attributes.
     * <br>
     * <br>
     * Use [yxmlattr_iter_next] function in order to retrieve a consecutive (**unordered**) attributes.
     * <br>
     * Use [yxmlattr_iter_destroy] function in order to close the iterator and release its resources.<br>
     * Original signature : <code>YrsXmlAttrIter* yxmlelem_attr_iter(const YrsBranch*, const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:1288</i>
     */
    YrsXmlAttrIter yxmlelem_attr_iter(YrsBranch xml, YrsTransaction txn);

    /**
     * Returns an iterator over the `YXmlText` attributes.
     * <br>
     * <br>
     * Use [yxmlattr_iter_next] function in order to retrieve a consecutive (**unordered**) attributes.
     * <br>
     * Use [yxmlattr_iter_destroy] function in order to close the iterator and release its resources.<br>
     * Original signature : <code>YrsXmlAttrIter* yxmltext_attr_iter(const YrsBranch*, const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:1296</i>
     */
    YrsXmlAttrIter yxmltext_attr_iter(YrsBranch xml, YrsTransaction txn);

    /**
     * Releases all of attributes iterator resources created by calling [yxmlelem_attr_iter]
     * <br>
     * or [yxmltext_attr_iter].<br>
     * Original signature : <code>void yxmlattr_iter_destroy(YrsXmlAttrIter*)</code><br>
     * <i>native declaration : libyrs.h:1302</i>
     */
    void yxmlattr_iter_destroy(YrsXmlAttrIter iterator);

    /**
     * Returns a next XML attribute from an `iterator`. Attributes are returned in an unordered
     * <br>
     * manner. Once `iterator` reaches the end of attributes collection, a null pointer will be
     * <br>
     * returned.
     * <br>
     * <br>
     * Returned value should be eventually released using [yxmlattr_destroy].<br>
     * Original signature : <code>YrsXmlAttr* yxmlattr_iter_next(YrsXmlAttrIter*)</code><br>
     * <i>native declaration : libyrs.h:1311</i>
     */
    YrsXmlAttr yxmlattr_iter_next(YrsXmlAttrIter iterator);

    /**
     * Returns a next sibling of a current XML node, which can be either another `YXmlElement`
     * <br>
     * or a `YXmlText`. Together with [yxmlelem_first_child] it may be used to iterate over the direct
     * <br>
     * children of an XML node (in order to iterate over the nested XML structure use
     * <br>
     * [yxmlelem_tree_walker]).
     * <br>
     * <br>
     * If current `YXmlElement` is the last child, this function returns a null pointer.
     * <br>
     * A returned value should be eventually released using [youtput_destroy] function.<br>
     * Original signature : <code>YrsOutput* yxml_next_sibling(const YrsBranch*, const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:1322</i>
     */
    YrsOutput yxml_next_sibling(YrsBranch xml, YrsTransaction txn);

    /**
     * Returns a previous sibling of a current XML node, which can be either another `YXmlElement`
     * <br>
     * or a `YXmlText`.
     * <br>
     * <br>
     * If current `YXmlElement` is the first child, this function returns a null pointer.
     * <br>
     * A returned value should be eventually released using [youtput_destroy] function.<br>
     * Original signature : <code>YrsOutput* yxml_prev_sibling(const YrsBranch*, const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:1331</i>
     */
    YrsOutput yxml_prev_sibling(YrsBranch xml, YrsTransaction txn);

    /**
     * Returns a parent `YXmlElement` of a current node, or null pointer when current `YXmlElement` is
     * <br>
     * a root-level shared data type.<br>
     * Original signature : <code>YrsBranch* yxmlelem_parent(const YrsBranch*)</code><br>
     * <i>native declaration : libyrs.h:1337</i>
     */
    YrsBranch yxmlelem_parent(YrsBranch xml);

    /**
     * Returns a number of child nodes (both `YXmlElement` and `YXmlText`) living under a current XML
     * <br>
     * element. This function doesn't count a recursive nodes, only direct children of a current node.<br>
     * Original signature : <code>uint32_t yxmlelem_child_len(const YrsBranch*, const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:1343</i>
     */
    int yxmlelem_child_len(YrsBranch xml, YrsTransaction txn);

    /**
     * Returns a first child node of a current `YXmlElement`, or null pointer if current XML node is
     * <br>
     * empty. Returned value could be either another `YXmlElement` or `YXmlText`.
     * <br>
     * <br>
     * A returned value should be eventually released using [youtput_destroy] function.<br>
     * Original signature : <code>YrsOutput* yxmlelem_first_child(const YrsBranch*)</code><br>
     * <i>native declaration : libyrs.h:1351</i>
     */
    YrsOutput yxmlelem_first_child(YrsBranch xml);

    /**
     * Returns an iterator over a nested recursive structure of a current `YXmlElement`, starting from
     * <br>
     * first of its children. Returned values can be either `YXmlElement` or `YXmlText` nodes.
     * <br>
     * <br>
     * Use [yxmlelem_tree_walker_next] function in order to iterate over to a next node.
     * <br>
     * Use [yxmlelem_tree_walker_destroy] function to release resources used by the iterator.<br>
     * Original signature : <code>YrsXmlTreeWalker* yxmlelem_tree_walker(const YrsBranch*, const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:1360</i>
     */
    YrsXmlTreeWalker yxmlelem_tree_walker(YrsBranch xml, YrsTransaction txn);

    /**
     * Releases resources associated with a current XML tree walker iterator.<br>
     * Original signature : <code>void yxmlelem_tree_walker_destroy(YrsXmlTreeWalker*)</code><br>
     * <i>native declaration : libyrs.h:1365</i>
     */
    void yxmlelem_tree_walker_destroy(YrsXmlTreeWalker iter);

    /**
     * Moves current `iterator` to a next value (either `YXmlElement` or `YXmlText`), returning its
     * <br>
     * pointer or a null, if an `iterator` already reached the last successor node.
     * <br>
     * <br>
     * Values returned by this function should be eventually released using [youtput_destroy].<br>
     * Original signature : <code>YrsOutput* yxmlelem_tree_walker_next(YrsXmlTreeWalker*)</code><br>
     * <i>native declaration : libyrs.h:1373</i>
     */
    YrsOutput yxmlelem_tree_walker_next(YrsXmlTreeWalker iterator);

    /**
     * Inserts an `YXmlElement` as a child of a current node at the given `index` and returns its
     * <br>
     * pointer. Node created this way will have a given `name` as its tag (eg. `p` for `<p></p>` node).
     * <br>
     * <br>
     * An `index` value must be between 0 and (inclusive) length of a current XML element (use
     * <br>
     * [yxmlelem_child_len] function to determine its length).
     * <br>
     * <br>
     * A `name` must be a null-terminated UTF-8 encoded string, which will be copied into current
     * <br>
     * document. Therefore `name` should be freed by the function caller.<br>
     * Original signature : <code>YrsBranch* yxmlelem_insert_elem(const YrsBranch*, YrsTransaction*, uint32_t, const char*)</code><br>
     * <i>native declaration : libyrs.h:1385</i>
     */
    YrsBranch yxmlelem_insert_elem(YrsBranch xml, YrsTransaction txn, int index, String name);

    /**
     * Inserts an `YXmlText` as a child of a current node at the given `index` and returns its
     * <br>
     * pointer.
     * <br>
     * <br>
     * An `index` value must be between 0 and (inclusive) length of a current XML element (use
     * <br>
     * [yxmlelem_child_len] function to determine its length).<br>
     * Original signature : <code>YrsBranch* yxmlelem_insert_text(const YrsBranch*, YrsTransaction*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1394</i>
     */
    YrsBranch yxmlelem_insert_text(YrsBranch xml, YrsTransaction txn, int index);

    /**
     * Removes a consecutive range of child elements (of specified length) from the current
     * <br>
     * `YXmlElement`, starting at the given `index`. Specified range must fit into boundaries of current
     * <br>
     * XML node children, otherwise this function will panic at runtime.<br>
     * Original signature : <code>void yxmlelem_remove_range(const YrsBranch*, YrsTransaction*, uint32_t, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1401</i>
     */
    void yxmlelem_remove_range(YrsBranch xml, YrsTransaction txn, int index, int len);

    /**
     * Returns an XML child node (either a `YXmlElement` or `YXmlText`) stored at a given `index` of
     * <br>
     * a current `YXmlElement`. Returns null pointer if `index` was outside of the bound of current XML
     * <br>
     * node children.
     * <br>
     * <br>
     * Returned value should be eventually released using [youtput_destroy].<br>
     * Original signature : <code>YrsOutput* yxmlelem_get(const YrsBranch*, const YrsTransaction*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1410</i>
     */
    YrsOutput yxmlelem_get(YrsBranch xml, YrsTransaction txn, int index);

    /**
     * Returns the length of the `YXmlText` string content in bytes (without the null terminator
     * <br>
     * character)<br>
     * Original signature : <code>uint32_t yxmltext_len(const YrsBranch*, const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:1416</i>
     */
    int yxmltext_len(YrsBranch txt, YrsTransaction txn);

    /**
     * Returns a null-terminated UTF-8 encoded string content of a current `YXmlText` shared data type.
     * <br>
     * <br>
     * Generated string resources should be released using [ystring_destroy] function.<br>
     * Original signature : <code>char* yxmltext_string(const YrsBranch*, const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:1423</i>
     */
    Pointer yxmltext_string(YrsBranch txt, YrsTransaction txn);

    /**
     * Inserts a null-terminated UTF-8 encoded string a a given `index`. `index` value must be between
     * <br>
     * 0 and a length of a `YXmlText` (inclusive, accordingly to [yxmltext_len] return value), otherwise
     * <br>
     * this function will panic.
     * <br>
     * <br>
     * A `str` parameter must be a null-terminated UTF-8 encoded string. This function doesn't take
     * <br>
     * ownership over a passed value - it will be copied and therefore a string parameter must be
     * <br>
     * released by the caller.
     * <br>
     * <br>
     * A nullable pointer with defined `attrs` will be used to wrap provided text with
     * <br>
     * a formatting blocks. `attrs` must be a map-like type.<br>
     * Original signature : <code>void yxmltext_insert(const YrsBranch*, YrsTransaction*, uint32_t, const char*, YrsInput*)</code><br>
     * <i>native declaration : libyrs.h:1437</i>
     */
    void yxmltext_insert(YrsBranch txt, YrsTransaction txn, int index, String str, YrsInput attrs);

    /**
     * Inserts an embed content given `index`. `index` value must be between 0 and a length of a
     * <br>
     * `YXmlText` (inclusive, accordingly to [ytext_len] return value), otherwise this
     * <br>
     * function will panic.
     * <br>
     * <br>
     * A `str` parameter must be a null-terminated UTF-8 encoded string. This function doesn't take
     * <br>
     * ownership over a passed value - it will be copied and therefore a string parameter must be
     * <br>
     * released by the caller.
     * <br>
     * <br>
     * A nullable pointer with defined `attrs` will be used to wrap provided text with
     * <br>
     * a formatting blocks. `attrs` must be a map-like type.<br>
     * Original signature : <code>void yxmltext_insert_embed(const YrsBranch*, YrsTransaction*, uint32_t, YrsInput*, YrsInput*)</code><br>
     * <i>native declaration : libyrs.h:1451</i>
     */
    void yxmltext_insert_embed(YrsBranch txt, YrsTransaction txn, int index, YrsInput content, YrsInput attrs);

    /**
     * Wraps an existing piece of text within a range described by `index`-`len` parameters with
     * <br>
     * formatting blocks containing provided `attrs` metadata. `attrs` must be a map-like type.<br>
     * Original signature : <code>void yxmltext_format(const YrsBranch*, YrsTransaction*, uint32_t, uint32_t, YrsInput*)</code><br>
     * <i>native declaration : libyrs.h:1457</i>
     */
    void yxmltext_format(YrsBranch txt, YrsTransaction txn, int index, int len, YrsInput attrs);

    /**
     * Removes a range of characters, starting a a given `index`. This range must fit within the bounds
     * <br>
     * of a current `YXmlText`, otherwise this function call will fail.
     * <br>
     * <br>
     * An `index` value must be between 0 and the length of a `YXmlText` (exclusive, accordingly to
     * <br>
     * [yxmltext_len] return value).
     * <br>
     * <br>
     * A `length` must be lower or equal number of characters (counted as UTF chars depending on the
     * <br>
     * encoding configured by `YrsDoc`) from `index` position to the end of of the string.<br>
     * Original signature : <code>void yxmltext_remove_range(const YrsBranch*, YrsTransaction*, uint32_t, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1469</i>
     */
    void yxmltext_remove_range(YrsBranch txt, YrsTransaction txn, int idx, int len);

    /**
     * Inserts an XML attribute described using `attr_name` and `attr_value`. If another attribute with
     * <br>
     * the same name already existed, its value will be replaced with a provided one.
     * <br>
     * <br>
     * Both `attr_name` and `attr_value` must be a null-terminated UTF-8 encoded strings. Their
     * <br>
     * contents are being copied, therefore it's up to a function caller to properly release them.<br>
     * Original signature : <code>void yxmltext_insert_attr(const YrsBranch*, YrsTransaction*, const char*, const char*)</code><br>
     * <i>native declaration : libyrs.h:1478</i>
     */
    void yxmltext_insert_attr(YrsBranch txt, YrsTransaction txn, String attr_name, String attr_value);

    /**
     * Removes an attribute from a current `YXmlText`, given its name.
     * <br>
     * <br>
     * An `attr_name`must be a null-terminated UTF-8 encoded string.<br>
     * Original signature : <code>void yxmltext_remove_attr(const YrsBranch*, YrsTransaction*, const char*)</code><br>
     * <i>native declaration : libyrs.h:1485</i>
     */
    void yxmltext_remove_attr(YrsBranch txt, YrsTransaction txn, String attr_name);


    /**
     * Returns the value of a current `YXmlText`, given its name, or a null pointer if not attribute
     * <br>
     * with such name has been found. Returned pointer is a null-terminated UTF-8 encoded string, which
     * <br>
     * should be released using [ystring_destroy] function.
     * <br>
     * <br>
     * An `attr_name` must be a null-terminated UTF-8 encoded string.<br>
     * Original signature : <code>char* yxmltext_get_attr(const YrsBranch*, const YrsTransaction*, const char*)</code><br>
     * <i>native declaration : libyrs.h:1494</i>
     */
    Pointer yxmltext_get_attr(YrsBranch txt, YrsTransaction txn, String attr_name);


    /**
     * Returns a collection of chunks representing pieces of `YText` rich text string grouped together
     * <br>
     * by the same formatting rules and type. `chunks_len` is used to inform about a number of chunks
     * <br>
     * generated this way.
     * <br>
     * <br>
     * Returned array needs to be eventually deallocated using `ychunks_destroy`.<br>
     * Original signature : <code>YrsChunk* ytext_chunks(const YrsBranch*, const YrsTransaction*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:1503</i>
     */
    YrsChunk ytext_chunks(YrsBranch txt, YrsTransaction txn, IntBuffer chunks_len);


    /**
     * Deallocates result of `ytext_chunks` method.<br>
     * Original signature : <code>void ychunks_destroy(YrsChunk*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1508</i>
     */
    void ychunks_destroy(YrsChunk chunks, int len);

    /**
     * Releases all resources related to a corresponding `YrsOutput` cell.<br>
     * Original signature : <code>void youtput_destroy(YrsOutput*)</code><br>
     * <i>native declaration : libyrs.h:1513</i>
     */
    void youtput_destroy(YrsOutput val);

    /**
     * Function constructor used to create JSON-like NULL `YrsInput` cell.
     * <br>
     * This function doesn't allocate any heap resources.<br>
     * Original signature : <code>YrsInput yinput_null()</code><br>
     * <i>native declaration : libyrs.h:1519</i>
     */
    YrsInput.ByValue yinput_null();

    /**
     * Function constructor used to create JSON-like undefined `YrsInput` cell.
     * <br>
     * This function doesn't allocate any heap resources.<br>
     * Original signature : <code>YrsInput yinput_undefined()</code><br>
     * <i>native declaration : libyrs.h:1525</i>
     */
    YrsInput.ByValue yinput_undefined();

    /**
     * Function constructor used to create JSON-like boolean `YrsInput` cell.
     * <br>
     * This function doesn't allocate any heap resources.<br>
     * Original signature : <code>YrsInput yinput_bool(uint8_t)</code><br>
     * <i>native declaration : libyrs.h:1531</i>
     */
    YrsInput.ByValue yinput_bool(byte flag);

    /**
     * Function constructor used to create JSON-like 64-bit floating point number `YrsInput` cell.
     * <br>
     * This function doesn't allocate any heap resources.<br>
     * Original signature : <code>YrsInput yinput_float(double)</code><br>
     * <i>native declaration : libyrs.h:1537</i>
     */
    YrsInput.ByValue yinput_float(double num);

    /**
     * Function constructor used to create JSON-like 64-bit signed integer `YrsInput` cell.
     * <br>
     * This function doesn't allocate any heap resources.<br>
     * Original signature : <code>YrsInput yinput_long(int64_t)</code><br>
     * <i>native declaration : libyrs.h:1543</i>
     */
    YrsInput.ByValue yinput_long(long integer);

    /**
     * Function constructor used to create a string `YrsInput` cell. Provided parameter must be
     * <br>
     * a null-terminated UTF-8 encoded string. This function doesn't allocate any heap resources,
     * <br>
     * and doesn't release any on its own, therefore its up to a caller to free resources once
     * <br>
     * a structure is no longer needed.<br>
     * Original signature : <code>YrsInput yinput_string(const char*)</code><br>
     * <i>native declaration : libyrs.h:1551</i>
     */
    YrsInput.ByValue yinput_string(String str);

    /**
     * Function constructor used to create a binary `YrsInput` cell of a specified length.
     * <br>
     * This function doesn't allocate any heap resources and doesn't release any on its own, therefore
     * <br>
     * its up to a caller to free resources once a structure is no longer needed.<br>
     * Original signature : <code>YrsInput yinput_binary(const char*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1558</i>
     */
    YrsInput.ByValue yinput_binary(byte[] buf, int len);

    /**
     * Function constructor used to create a JSON-like array `YrsInput` cell of other JSON-like values of
     * <br>
     * a given length. This function doesn't allocate any heap resources and doesn't release any on its
     * <br>
     * own, therefore its up to a caller to free resources once a structure is no longer needed.<br>
     * Original signature : <code>YrsInput yinput_json_array(YrsInput*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1565</i>
     */
    YrsInput.ByValue yinput_json_array(YrsInput[] values, int len);

    /**
     * Function constructor used to create a JSON-like map `YrsInput` cell of other JSON-like key-value
     * <br>
     * pairs. These pairs are build from corresponding indexes of `keys` and `values`, which must have
     * <br>
     * the same specified length.
     * <br>
     * <br>
     * This function doesn't allocate any heap resources and doesn't release any on its own, therefore
     * <br>
     * its up to a caller to free resources once a structure is no longer needed.<br>
     * Original signature : <code>YrsInput yinput_json_map(char**, YrsInput*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1575</i>
     */
    YrsInput.ByValue yinput_json_map(String[] keys, YrsInput[] values, int len);

    /**
     * Function constructor used to create a nested `YArray` `YrsInput` cell prefilled with other
     * <br>
     * values of a given length. This function doesn't allocate any heap resources and doesn't release
     * <br>
     * any on its own, therefore its up to a caller to free resources once a structure is no longer
     * <br>
     * needed.<br>
     * Original signature : <code>YrsInput yinput_yarray(YrsInput*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1583</i>
     */
    YrsInput.ByValue yinput_yarray(YrsInput[] array, int len);

    /**
     * Function constructor used to create a nested `YMap` `YrsInput` cell prefilled with other key-value
     * <br>
     * pairs. These pairs are build from corresponding indexes of `keys` and `values`, which must have
     * <br>
     * the same specified length.
     * <br>
     * <br>
     * This function doesn't allocate any heap resources and doesn't release any on its own, therefore
     * <br>
     * its up to a caller to free resources once a structure is no longer needed.<br>
     * Original signature : <code>YrsInput yinput_ymap(char**, YrsInput*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1593</i>
     */
    YrsInput.ByValue yinput_ymap(String[] keys, YrsInput[] values, int len);

    /**
     * Function constructor used to create a nested `YText` `YrsInput` cell prefilled with a specified
     * <br>
     * string, which must be a null-terminated UTF-8 character pointer.
     * <br>
     * <br>
     * This function doesn't allocate any heap resources and doesn't release any on its own, therefore
     * <br>
     * its up to a caller to free resources once a structure is no longer needed.<br>
     * Original signature : <code>YrsInput yinput_ytext(char*)</code><br>
     * <i>native declaration : libyrs.h:1602</i>
     */
    YrsInput.ByValue yinput_ytext(String str);

    /**
     * Function constructor used to create a nested `YXmlElement` `YrsInput` cell with a specified
     * <br>
     * tag name, which must be a null-terminated UTF-8 character pointer.
     * <br>
     * <br>
     * This function doesn't allocate any heap resources and doesn't release any on its own, therefore
     * <br>
     * its up to a caller to free resources once a structure is no longer needed.<br>
     * Original signature : <code>YrsInput yinput_yxmlelem(char*)</code><br>
     * <i>native declaration : libyrs.h:1611</i>
     */
    YrsInput.ByValue yinput_yxmlelem(String name);

    /**
     * Function constructor used to create a nested `YXmlText` `YrsInput` cell prefilled with a specified
     * <br>
     * string, which must be a null-terminated UTF-8 character pointer.
     * <br>
     * <br>
     * This function doesn't allocate any heap resources and doesn't release any on its own, therefore
     * <br>
     * its up to a caller to free resources once a structure is no longer needed.<br>
     * Original signature : <code>YrsInput yinput_yxmltext(char*)</code><br>
     * <i>native declaration : libyrs.h:1620</i>
     */
    YrsInput.ByValue yinput_yxmltext(String str);

    /**
     * Function constructor used to create a nested `YrsDoc` `YrsInput` cell.
     * <br>
     * <br>
     * This function doesn't allocate any heap resources and doesn't release any on its own, therefore
     * <br>
     * its up to a caller to free resources once a structure is no longer needed.<br>
     * Original signature : <code>YrsInput yinput_ydoc(YrsDoc*)</code><br>
     * <i>native declaration : libyrs.h:1628</i>
     */
    YrsInput.ByValue yinput_ydoc(YrsDoc doc);

    /**
     * Function constructor used to create a string `YrsInput` cell with weak reference to another
     * <br>
     * element(s) living inside of the same document.<br>
     * Original signature : <code>YrsInput yinput_weak(const Weak*)</code><br>
     * <i>native declaration : libyrs.h:1634</i>
     */
    YrsInput.ByValue yinput_weak(YrsLinkSource weak);

    /**
     * Attempts to read the value for a given `YrsOutput` pointer as a `YDocRef` reference to a nested
     * <br>
     * document.<br>
     * Original signature : <code>YrsDoc* youtput_read_ydoc(YrsOutput*)</code><br>
     * <i>native declaration : libyrs.h:1640</i>
     */
    YrsDoc youtput_read_ydoc(YrsOutput val);

    /**
     * Attempts to read the value for a given `YrsOutput` pointer as a boolean flag, which can be either
     * <br>
     * `1` for truthy case and `0` otherwise. Returns a null pointer in case when a value stored under
     * <br>
     * current `YrsOutput` cell is not of a boolean type.<br>
     * Original signature : <code>uint8_t* youtput_read_bool(YrsOutput*)</code><br>
     * <i>native declaration : libyrs.h:1647</i>
     */
    Pointer youtput_read_bool(YrsOutput val);

    /**
     * Attempts to read the value for a given `YrsOutput` pointer as a 64-bit floating point number.
     * <br>
     * <br>
     * Returns a null pointer in case when a value stored under current `YrsOutput` cell
     * <br>
     * is not a floating point number.<br>
     * Original signature : <code>double* youtput_read_float(YrsOutput*)</code><br>
     * <i>native declaration : libyrs.h:1655</i>
     */
    DoubleByReference youtput_read_float(YrsOutput val);

    /**
     * Attempts to read the value for a given `YrsOutput` pointer as a 64-bit signed integer.
     * <br>
     * <br>
     * Returns a null pointer in case when a value stored under current `YrsOutput` cell
     * <br>
     * is not a signed integer.<br>
     * Original signature : <code>int64_t* youtput_read_long(YrsOutput*)</code><br>
     * <i>native declaration : libyrs.h:1663</i>
     */
    LongByReference youtput_read_long(YrsOutput val);

    /**
     * Attempts to read the value for a given `YrsOutput` pointer as a null-terminated UTF-8 encoded
     * <br>
     * string.
     * <br>
     * <br>
     * Returns a null pointer in case when a value stored under current `YrsOutput` cell
     * <br>
     * is not a string. Underlying string is released automatically as part of [youtput_destroy]
     * <br>
     * destructor.<br>
     * Original signature : <code>char* youtput_read_string(YrsOutput*)</code><br>
     * <i>native declaration : libyrs.h:1673</i>
     */
    Pointer youtput_read_string(YrsOutput val);

    /**
     * Attempts to read the value for a given `YrsOutput` pointer as a binary payload (which length is
     * <br>
     * stored within `len` filed of a cell itself).
     * <br>
     * <br>
     * Returns a null pointer in case when a value stored under current `YrsOutput` cell
     * <br>
     * is not a binary type. Underlying binary is released automatically as part of [youtput_destroy]
     * <br>
     * destructor.<br>
     * Original signature : <code>char* youtput_read_binary(YrsOutput*)</code><br>
     * <i>native declaration : libyrs.h:1683</i>
     */
    Pointer youtput_read_binary(YrsOutput val);

    /**
     * Attempts to read the value for a given `YrsOutput` pointer as a JSON-like array of `YrsOutput`
     * <br>
     * values (which length is stored within `len` filed of a cell itself).
     * <br>
     * <br>
     * Returns a null pointer in case when a value stored under current `YrsOutput` cell
     * <br>
     * is not a JSON-like array. Underlying heap resources are released automatically as part of
     * <br>
     * [youtput_destroy] destructor.<br>
     * Original signature : <code>YrsOutput* youtput_read_json_array(YrsOutput*)</code><br>
     * <i>native declaration : libyrs.h:1693</i>
     */
    YrsOutput youtput_read_json_array(YrsOutput val);

    /**
     * Attempts to read the value for a given `YrsOutput` pointer as a JSON-like map of key-value entries
     * <br>
     * (which length is stored within `len` filed of a cell itself).
     * <br>
     * <br>
     * Returns a null pointer in case when a value stored under current `YrsOutput` cell
     * <br>
     * is not a JSON-like map. Underlying heap resources are released automatically as part of
     * <br>
     * [youtput_destroy] destructor.<br>
     * Original signature : <code>YrsMapEntry* youtput_read_json_map(YrsOutput*)</code><br>
     * <i>native declaration : libyrs.h:1703</i>
     */
    YrsMapEntry youtput_read_json_map(YrsOutput val);

    /**
     * Attempts to read the value for a given `YrsOutput` pointer as an `YArray`.
     * <br>
     * <br>
     * Returns a null pointer in case when a value stored under current `YrsOutput` cell
     * <br>
     * is not an `YArray`. Underlying heap resources are released automatically as part of
     * <br>
     * [youtput_destroy] destructor.<br>
     * Original signature : <code>YrsBranch* youtput_read_yarray(YrsOutput*)</code><br>
     * <i>native declaration : libyrs.h:1712</i>
     */
    YrsBranch youtput_read_yarray(YrsOutput val);

    /**
     * Attempts to read the value for a given `YrsOutput` pointer as an `YXmlElement`.
     * <br>
     * <br>
     * Returns a null pointer in case when a value stored under current `YrsOutput` cell
     * <br>
     * is not an `YXmlElement`. Underlying heap resources are released automatically as part of
     * <br>
     * [youtput_destroy] destructor.<br>
     * Original signature : <code>YrsBranch* youtput_read_yxmlelem(YrsOutput*)</code><br>
     * <i>native declaration : libyrs.h:1721</i>
     */
    YrsBranch youtput_read_yxmlelem(YrsOutput val);

    /**
     * Attempts to read the value for a given `YrsOutput` pointer as an `YMap`.
     * <br>
     * <br>
     * Returns a null pointer in case when a value stored under current `YrsOutput` cell
     * <br>
     * is not an `YMap`. Underlying heap resources are released automatically as part of
     * <br>
     * [youtput_destroy] destructor.<br>
     * Original signature : <code>YrsBranch* youtput_read_ymap(YrsOutput*)</code><br>
     * <i>native declaration : libyrs.h:1730</i>
     */
    YrsBranch youtput_read_ymap(YrsOutput val);

    /**
     * Attempts to read the value for a given `YrsOutput` pointer as an `YText`.
     * <br>
     * <br>
     * Returns a null pointer in case when a value stored under current `YrsOutput` cell
     * <br>
     * is not an `YText`. Underlying heap resources are released automatically as part of
     * <br>
     * [youtput_destroy] destructor.<br>
     * Original signature : <code>YrsBranch* youtput_read_ytext(YrsOutput*)</code><br>
     * <i>native declaration : libyrs.h:1739</i>
     */
    YrsBranch youtput_read_ytext(YrsOutput val);

    /**
     * Attempts to read the value for a given `YrsOutput` pointer as an `YXmlText`.
     * <br>
     * <br>
     * Returns a null pointer in case when a value stored under current `YrsOutput` cell
     * <br>
     * is not an `YXmlText`. Underlying heap resources are released automatically as part of
     * <br>
     * [youtput_destroy] destructor.<br>
     * Original signature : <code>YrsBranch* youtput_read_yxmltext(YrsOutput*)</code><br>
     * <i>native declaration : libyrs.h:1748</i>
     */
    YrsBranch youtput_read_yxmltext(YrsOutput val);

    /**
     * Attempts to read the value for a given `YrsOutput` pointer as an `YWeakRef`.
     * <br>
     * <br>
     * Returns a null pointer in case when a value stored under current `YrsOutput` cell
     * <br>
     * is not an `YWeakRef`. Underlying heap resources are released automatically as part of
     * <br>
     * [youtput_destroy] destructor.<br>
     * Original signature : <code>YrsBranch* youtput_read_yweak(YrsOutput*)</code><br>
     * <i>native declaration : libyrs.h:1757</i>
     */
    YrsBranch youtput_read_yweak(YrsOutput val);

    /**
     * Unsubscribe callback from the oberver event it was previously subscribed to.<br>
     * Original signature : <code>void yunobserve(YrsSubscription*)</code><br>
     * <i>native declaration : libyrs.h:1762</i>
     */
    void yunobserve(YrsSubscription subscription);

    /**
     * Subscribes a given callback function `cb` to changes made by this `YText` instance. Callbacks
     * <br>
     * are triggered whenever a `ytransaction_commit` is called.
     * <br>
     * Returns a subscription ID which can be then used to unsubscribe this callback by using
     * <br>
     * `yunobserve` function.<br>
     * Original signature : <code>YrsSubscription* ytext_observe(const YrsBranch*, void*, ytext_observe_cb_callback*)</code><br>
     * <i>native declaration : libyrs.h:1770</i>
     */
    YrsSubscription ytext_observe(YrsBranch txt, Pointer state, ytext_observe_cb_callback cb);

    /**
     * Subscribes a given callback function `cb` to changes made by this `YMap` instance. Callbacks
     * <br>
     * are triggered whenever a `ytransaction_commit` is called.
     * <br>
     * Returns a subscription ID which can be then used to unsubscribe this callback by using
     * <br>
     * `yunobserve` function.<br>
     * Original signature : <code>YrsSubscription* ymap_observe(const YrsBranch*, void*, ymap_observe_cb_callback*)</code><br>
     * <i>native declaration : libyrs.h:1778</i>
     */
    YrsSubscription ymap_observe(YrsBranch map, Pointer state, ymap_observe_cb_callback cb);

    /**
     * Subscribes a given callback function `cb` to changes made by this `YArray` instance. Callbacks
     * <br>
     * are triggered whenever a `ytransaction_commit` is called.
     * <br>
     * Returns a subscription ID which can be then used to unsubscribe this callback by using
     * <br>
     * `yunobserve` function.<br>
     * Original signature : <code>YrsSubscription* yarray_observe(const YrsBranch*, void*, yarray_observe_cb_callback*)</code><br>
     * <i>native declaration : libyrs.h:1786</i>
     */
    YrsSubscription yarray_observe(YrsBranch array, Pointer state, yarray_observe_cb_callback cb);

    /**
     * Subscribes a given callback function `cb` to changes made by this `YXmlElement` instance.
     * <br>
     * Callbacks are triggered whenever a `ytransaction_commit` is called.
     * <br>
     * Returns a subscription ID which can be then used to unsubscribe this callback by using
     * <br>
     * `yunobserve` function.<br>
     * Original signature : <code>YrsSubscription* yxmlelem_observe(const YrsBranch*, void*, yxmlelem_observe_cb_callback*)</code><br>
     * <i>native declaration : libyrs.h:1794</i>
     */
    YrsSubscription yxmlelem_observe(YrsBranch xml, Pointer state, yxmlelem_observe_cb_callback cb);

    /**
     * Subscribes a given callback function `cb` to changes made by this `YXmlText` instance. Callbacks
     * <br>
     * are triggered whenever a `ytransaction_commit` is called.
     * <br>
     * Returns a subscription ID which can be then used to unsubscribe this callback by using
     * <br>
     * `yunobserve` function.<br>
     * Original signature : <code>YrsSubscription* yxmltext_observe(const YrsBranch*, void*, yxmltext_observe_cb_callback*)</code><br>
     * <i>native declaration : libyrs.h:1802</i>
     */
    YrsSubscription yxmltext_observe(YrsBranch xml, Pointer state, yxmltext_observe_cb_callback cb);

    /**
     * Subscribes a given callback function `cb` to changes made by this shared type instance as well
     * <br>
     * as all nested shared types living within it. Callbacks are triggered whenever a
     * <br>
     * `ytransaction_commit` is called.
     * <br>
     * <br>
     * Returns a subscription ID which can be then used to unsubscribe this callback by using
     * <br>
     * `yunobserve` function.<br>
     * Original signature : <code>YrsSubscription* yobserve_deep(YrsBranch*, void*, yobserve_deep_cb_callback*)</code><br>
     * <i>native declaration : libyrs.h:1812</i>
     */
    YrsSubscription yobserve_deep(YrsBranch ytype, Pointer state, yobserve_deep_cb_callback cb);

    /**
     * Returns a pointer to a shared collection, which triggered passed event `e`.<br>
     * Original signature : <code>YrsBranch* ytext_event_target(YrsTextEvent*)</code><br>
     * <i>native declaration : libyrs.h:1817</i>
     */
    YrsBranch ytext_event_target(YrsTextEvent e);

    /**
     * Returns a pointer to a shared collection, which triggered passed event `e`.<br>
     * Original signature : <code>YrsBranch* yarray_event_target(YrsArrayEvent*)</code><br>
     * <i>native declaration : libyrs.h:1822</i>
     */
    YrsBranch yarray_event_target(YrsArrayEvent e);

    /**
     * Returns a pointer to a shared collection, which triggered passed event `e`.<br>
     * Original signature : <code>YrsBranch* ymap_event_target(YrsMapEvent*)</code><br>
     * <i>native declaration : libyrs.h:1827</i>
     */
    YrsBranch ymap_event_target(YrsMapEvent e);

    /**
     * Returns a pointer to a shared collection, which triggered passed event `e`.<br>
     * Original signature : <code>YrsBranch* yxmlelem_event_target(YrsXmlEvent*)</code><br>
     * <i>native declaration : libyrs.h:1832</i>
     */
    YrsBranch yxmlelem_event_target(YrsXmlEvent e);

    /**
     * Returns a pointer to a shared collection, which triggered passed event `e`.<br>
     * Original signature : <code>YrsBranch* yxmltext_event_target(YrsXmlTextEvent*)</code><br>
     * <i>native declaration : libyrs.h:1837</i>
     */
    YrsBranch yxmltext_event_target(YrsXmlTextEvent e);

    /**
     * Returns a path from a root type down to a current shared collection (which can be obtained using
     * <br>
     * `ytext_event_target` function). It can consist of either integer indexes (used by sequence
     * <br>
     * components) of *char keys (used by map components). `len` output parameter is used to provide
     * <br>
     * information about length of the path.
     * <br>
     * <br>
     * Path returned this way should be eventually released using `ypath_destroy`.<br>
     * Original signature : <code>YrsPathSegment* ytext_event_path(YrsTextEvent*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:1847</i>
     */
    YrsPathSegment ytext_event_path(YrsTextEvent e, IntBuffer len);

    /**
     * Returns a path from a root type down to a current shared collection (which can be obtained using
     * <br>
     * `ymap_event_target` function). It can consist of either integer indexes (used by sequence
     * <br>
     * components) of *char keys (used by map components). `len` output parameter is used to provide
     * <br>
     * information about length of the path.
     * <br>
     * <br>
     * Path returned this way should be eventually released using `ypath_destroy`.<br>
     * Original signature : <code>YrsPathSegment* ymap_event_path(YrsMapEvent*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:1857</i>
     */
    YrsPathSegment ymap_event_path(YrsMapEvent e, IntBuffer len);

    /**
     * Returns a path from a root type down to a current shared collection (which can be obtained using
     * <br>
     * `yxmlelem_event_path` function). It can consist of either integer indexes (used by sequence
     * <br>
     * components) of *char keys (used by map components). `len` output parameter is used to provide
     * <br>
     * information about length of the path.
     * <br>
     * <br>
     * Path returned this way should be eventually released using `ypath_destroy`.<br>
     * Original signature : <code>YrsPathSegment* yxmlelem_event_path(YrsXmlEvent*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:1867</i>
     */
    YrsPathSegment yxmlelem_event_path(YrsXmlEvent e, IntBuffer len);

    /**
     * Returns a path from a root type down to a current shared collection (which can be obtained using
     * <br>
     * `yxmltext_event_path` function). It can consist of either integer indexes (used by sequence
     * <br>
     * components) of *char keys (used by map components). `len` output parameter is used to provide
     * <br>
     * information about length of the path.
     * <br>
     * <br>
     * Path returned this way should be eventually released using `ypath_destroy`.<br>
     * Original signature : <code>YrsPathSegment* yxmltext_event_path(YrsXmlTextEvent*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:1877</i>
     */
    YrsPathSegment yxmltext_event_path(YrsXmlTextEvent e, IntBuffer len);

    /**
     * Returns a path from a root type down to a current shared collection (which can be obtained using
     * <br>
     * `yarray_event_target` function). It can consist of either integer indexes (used by sequence
     * <br>
     * components) of *char keys (used by map components). `len` output parameter is used to provide
     * <br>
     * information about length of the path.
     * <br>
     * <br>
     * Path returned this way should be eventually released using `ypath_destroy`.<br>
     * Original signature : <code>YrsPathSegment* yarray_event_path(YrsArrayEvent*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:1887</i>
     */
    YrsPathSegment yarray_event_path(YrsArrayEvent e, IntBuffer len);

    /**
     * Releases allocated memory used by objects returned from path accessor functions of shared type
     * <br>
     * events.<br>
     * Original signature : <code>void ypath_destroy(YrsPathSegment*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1893</i>
     */
    void ypath_destroy(YrsPathSegment path, int len);

    /**
     * Returns a sequence of changes produced by sequence component of shared collections (such as
     * <br>
     * `YText`, `YXmlText` and XML nodes added to `YXmlElement`). `len` output parameter is used to
     * <br>
     * provide information about number of changes produced.
     * <br>
     * <br>
     * Delta returned from this function should eventually be released using `yevent_delta_destroy`
     * <br>
     * function.<br>
     * Original signature : <code>YrsDelta* ytext_event_delta(YrsTextEvent*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:1903</i>
     */
    YrsDelta ytext_event_delta(YrsTextEvent e, IntBuffer len);

    /**
     * Returns a sequence of changes produced by sequence component of shared collections (such as
     * <br>
     * `YText`, `YXmlText` and XML nodes added to `YXmlElement`). `len` output parameter is used to
     * <br>
     * provide information about number of changes produced.
     * <br>
     * <br>
     * Delta returned from this function should eventually be released using `yevent_delta_destroy`
     * <br>
     * function.<br>
     * Original signature : <code>YrsDelta* yxmltext_event_delta(YrsXmlTextEvent*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:1913</i>
     */
    YrsDelta yxmltext_event_delta(YrsXmlTextEvent e, IntBuffer len);

    /**
     * Returns a sequence of changes produced by sequence component of shared collections (such as
     * <br>
     * `YText`, `YXmlText` and XML nodes added to `YXmlElement`). `len` output parameter is used to
     * <br>
     * provide information about number of changes produced.
     * <br>
     * <br>
     * Delta returned from this function should eventually be released using `yevent_delta_destroy`
     * <br>
     * function.<br>
     * Original signature : <code>YrsEventChange* yarray_event_delta(YrsArrayEvent*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:1923</i>
     */
    YrsEventChange yarray_event_delta(YrsArrayEvent e, IntBuffer len);

    /**
     * Returns a sequence of changes produced by sequence component of shared collections (such as
     * <br>
     * `YText`, `YXmlText` and XML nodes added to `YXmlElement`). `len` output parameter is used to
     * <br>
     * provide information about number of changes produced.
     * <br>
     * <br>
     * Delta returned from this function should eventually be released using `yevent_delta_destroy`
     * <br>
     * function.<br>
     * Original signature : <code>YrsEventChange* yxmlelem_event_delta(YrsXmlEvent*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:1933</i>
     */
    YrsEventChange yxmlelem_event_delta(YrsXmlEvent e, IntBuffer len);

    /**
     * Releases memory allocated by the object returned from `yevent_delta` function.<br>
     * Original signature : <code>void ytext_delta_destroy(YrsDelta*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1938</i>
     */
    void ytext_delta_destroy(YrsDelta delta, int len);

    /**
     * Releases memory allocated by the object returned from `yevent_delta` function.<br>
     * Original signature : <code>void yevent_delta_destroy(YrsEventChange*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1943</i>
     */
    void yevent_delta_destroy(YrsEventChange delta, int len);

    /**
     * Returns a sequence of changes produced by map component of shared collections (such as
     * <br>
     * `YMap` and `YXmlText`/`YXmlElement` attribute changes). `len` output parameter is used to
     * <br>
     * provide information about number of changes produced.
     * <br>
     * <br>
     * Delta returned from this function should eventually be released using `yevent_keys_destroy`
     * <br>
     * function.<br>
     * Original signature : <code>YrsEventKeyChange* ymap_event_keys(YrsMapEvent*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:1953</i>
     */
    YrsEventKeyChange ymap_event_keys(YrsMapEvent e, IntBuffer len);

    /**
     * Returns a sequence of changes produced by map component of shared collections.
     * <br>
     * `len` output parameter is used to provide information about number of changes produced.
     * <br>
     * <br>
     * Delta returned from this function should eventually be released using `yevent_keys_destroy`
     * <br>
     * function.<br>
     * Original signature : <code>YrsEventKeyChange* yxmlelem_event_keys(YrsXmlEvent*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:1962</i>
     */
    YrsEventKeyChange yxmlelem_event_keys(YrsXmlEvent e, IntBuffer len);

    /**
     * Returns a sequence of changes produced by map component of shared collections.
     * <br>
     * `len` output parameter is used to provide information about number of changes produced.
     * <br>
     * <br>
     * Delta returned from this function should eventually be released using `yevent_keys_destroy`
     * <br>
     * function.<br>
     * Original signature : <code>YrsEventKeyChange* yxmltext_event_keys(YrsXmlTextEvent*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:1971</i>
     */
    YrsEventKeyChange yxmltext_event_keys(YrsXmlTextEvent e, IntBuffer len);

    /**
     * Releases memory allocated by the object returned from `yxml_event_keys` and `ymap_event_keys`
     * <br>
     * functions.<br>
     * Original signature : <code>void yevent_keys_destroy(YrsEventKeyChange*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:1977</i>
     */
    void yevent_keys_destroy(YrsEventKeyChange keys, int len);

    /**
     * Original signature : <code>YrsUndoManager* yundo_manager(const YrsDoc*, const YrsBranch*, YrsUndoManagerOptions*)</code><br>
     * <i>native declaration : libyrs.h:1979</i>
     */
    YrsUndoManager yundo_manager(YrsDoc doc, YrsBranch ytype, YrsUndoManagerOptions options);

    /**
     * Original signature : <code>void yundo_manager_destroy(YrsUndoManager*)</code><br>
     * <i>native declaration : libyrs.h:1981</i>
     */
    void yundo_manager_destroy(YrsUndoManager mgr);

    /**
     * Original signature : <code>void yundo_manager_add_origin(YrsUndoManager*, uint32_t, const char*)</code><br>
     * <i>native declaration : libyrs.h:1983</i>
     */
    void yundo_manager_add_origin(YrsUndoManager mgr, int origin_len, String origin);

    /**
     * Original signature : <code>void yundo_manager_remove_origin(YrsUndoManager*, uint32_t, const char*)</code><br>
     * <i>native declaration : libyrs.h:1985</i>
     */
    void yundo_manager_remove_origin(YrsUndoManager mgr, int origin_len, String origin);

    /**
     * Original signature : <code>void yundo_manager_add_scope(YrsUndoManager*, const YrsBranch*)</code><br>
     * <i>native declaration : libyrs.h:1987</i>
     */
    void yundo_manager_add_scope(YrsUndoManager mgr, YrsBranch ytype);

    /**
     * Original signature : <code>uint8_t yundo_manager_clear(YrsUndoManager*)</code><br>
     * <i>native declaration : libyrs.h:1989</i>
     */
    byte yundo_manager_clear(YrsUndoManager mgr);

    /**
     * Original signature : <code>void yundo_manager_stop(YrsUndoManager*)</code><br>
     * <i>native declaration : libyrs.h:1991</i>
     */
    void yundo_manager_stop(YrsUndoManager mgr);

    /**
     * Original signature : <code>uint8_t yundo_manager_undo(YrsUndoManager*)</code><br>
     * <i>native declaration : libyrs.h:1993</i>
     */
    byte yundo_manager_undo(YrsUndoManager mgr);

    /**
     * Original signature : <code>uint8_t yundo_manager_redo(YrsUndoManager*)</code><br>
     * <i>native declaration : libyrs.h:1995</i>
     */
    byte yundo_manager_redo(YrsUndoManager mgr);

    /**
     * Original signature : <code>uint8_t yundo_manager_can_undo(YrsUndoManager*)</code><br>
     * <i>native declaration : libyrs.h:1997</i>
     */
    byte yundo_manager_can_undo(YrsUndoManager mgr);

    /**
     * Original signature : <code>uint8_t yundo_manager_can_redo(YrsUndoManager*)</code><br>
     * <i>native declaration : libyrs.h:1999</i>
     */
    byte yundo_manager_can_redo(YrsUndoManager mgr);

    /**
     * Original signature : <code>YrsSubscription* yundo_manager_observe_added(YrsUndoManager*, void*, yundo_manager_observe_added_cb_callback*)</code><br>
     * <i>native declaration : libyrs.h:2001</i>
     */
    YrsSubscription yundo_manager_observe_added(YrsUndoManager mgr, Pointer state, yundo_manager_observe_added_cb_callback cb);

    /**
     * Original signature : <code>YrsSubscription* yundo_manager_observe_popped(YrsUndoManager*, void*, yundo_manager_observe_popped_cb_callback*)</code><br>
     * <i>native declaration : libyrs.h:2003</i>
     */
    YrsSubscription yundo_manager_observe_popped(YrsUndoManager mgr, Pointer state, yundo_manager_observe_popped_cb_callback cb);

    /**
     * Returns a value informing what kind of Yrs shared collection given `yrsBranch` represents.
     * <br>
     * Returns either 0 when `yrsBranch` is null or one of values: `Y_ARRAY`, `Y_TEXT`, `Y_MAP`,
     * <br>
     * `Y_XML_ELEM`, `Y_XML_TEXT`.<br>
     * Original signature : <code>int8_t ytype_kind(const YrsBranch*)</code><br>
     * <i>native declaration : libyrs.h:2010</i>
     */
    byte ytype_kind(YrsBranch yrsBranch);

    /**
     * Releases resources allocated by `YStickyIndex` pointers.<br>
     * Original signature : <code>void ysticky_index_destroy(YStickyIndex*)</code><br>
     * <i>native declaration : libyrs.h:2015</i>
     */
    void ysticky_index_destroy(YrsStickyIndex pos);

    /**
     * Returns association of current `YStickyIndex`.
     * <br>
     * If association is **after** the referenced inserted character, returned number will be >= 0.
     * <br>
     * If association is **before** the referenced inserted character, returned number will be < 0.<br>
     * Original signature : <code>int8_t ysticky_index_assoc(const YStickyIndex*)</code><br>
     * <i>native declaration : libyrs.h:2022</i>
     */
    byte ysticky_index_assoc(YrsStickyIndex pos);

    /**
     * Retrieves a `YStickyIndex` corresponding to a given human-readable `index` pointing into
     * <br>
     * the shared y-type `yrsBranch`. Unlike standard indexes sticky one enables to track
     * <br>
     * the location inside of a shared y-types, even in the face of concurrent updates.
     * <br>
     * <br>
     * If association is >= 0, the resulting position will point to location **after** the referenced index.
     * <br>
     * If association is < 0, the resulting position will point to location **before** the referenced index.<br>
     * Original signature : <code>YStickyIndex* ysticky_index_from_index(const YrsBranch*, YrsTransaction*, uint32_t, int8_t)</code><br>
     * <i>native declaration : libyrs.h:2032</i>
     */
    YrsStickyIndex ysticky_index_from_index(YrsBranch yrsBranch, YrsTransaction txn, int index, byte assoc);

    /**
     * Serializes `YStickyIndex` into binary representation. `len` parameter is updated with byte
     * <br>
     * length of the generated binary. Returned binary can be free'd using `ybinary_destroy`.<br>
     * Original signature : <code>char* ysticky_index_encode(const YStickyIndex*, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:2038</i>
     */
    Pointer ysticky_index_encode(YrsStickyIndex pos, IntBuffer len);

    /**
     * Deserializes `YStickyIndex` from the payload previously serialized using `ysticky_index_encode`.<br>
     * Original signature : <code>YStickyIndex* ysticky_index_decode(const char*, uint32_t)</code><br>
     * <i>native declaration : libyrs.h:2043</i>
     */
    YrsStickyIndex ysticky_index_decode(String binary, int len);

    /**
     * Given `YStickyIndex` and transaction reference, if computes a human-readable index in a
     * <br>
     * context of the referenced shared y-type.
     * <br>
     * <br>
     * `out_branch` is getting assigned with a corresponding shared y-type reference.
     * <br>
     * `out_index` will be used to store computed human-readable index.<br>
     * Original signature : <code>void ysticky_index_read(const YStickyIndex*, const YrsTransaction*, YrsBranch**, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:2052</i>
     */
    void ysticky_index_read(YrsStickyIndex pos, YrsTransaction txn, YrsBranch.ByReference[] out_branch, IntBuffer out_index);

    /**
     * Given `YStickyIndex` and transaction reference, if computes a human-readable index in a
     * <br>
     * context of the referenced shared y-type.
     * <br>
     * <br>
     * `out_branch` is getting assigned with a corresponding shared y-type reference.
     * <br>
     * `out_index` will be used to store computed human-readable index.<br>
     * Original signature : <code>void ysticky_index_read(const YStickyIndex*, const YrsTransaction*, YrsBranch**, uint32_t*)</code><br>
     * <i>native declaration : libyrs.h:2052</i>
     */
    void ysticky_index_read(YrsStickyIndex pos, YrsTransaction txn, YrsBranch.ByReference[] out_branch, IntByReference out_index);

    /**
     * Original signature : <code>void yweak_destroy(const Weak*)</code><br>
     * <i>native declaration : libyrs.h:2054</i>
     */
    void yweak_destroy(YrsLinkSource weak);

    /**
     * Original signature : <code>YrsOutput* yweak_deref(const YrsBranch*, const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:2056</i>
     */
    YrsOutput yweak_deref(YrsBranch map_link, YrsTransaction txn);

    /**
     * Original signature : <code>YrsWeakIter* yweak_iter(const YrsBranch*, const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:2058</i>
     */
    YrsWeakIter yweak_iter(YrsBranch array_link, YrsTransaction txn);

    /**
     * Original signature : <code>void yweak_iter_destroy(YrsWeakIter*)</code><br>
     * <i>native declaration : libyrs.h:2060</i>
     */
    void yweak_iter_destroy(YrsWeakIter iter);

    /**
     * Original signature : <code>YrsOutput* yweak_iter_next(YrsWeakIter*)</code><br>
     * <i>native declaration : libyrs.h:2062</i>
     */
    YrsOutput yweak_iter_next(YrsWeakIter iter);

    /**
     * Original signature : <code>char* yweak_string(const YrsBranch*, const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:2064</i>
     */
    Pointer yweak_string(YrsBranch text_link, YrsTransaction txn);

    /**
     * Original signature : <code>char* yweak_xml_string(const YrsBranch*, const YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:2066</i>
     */
    Pointer yweak_xml_string(YrsBranch xml_text_link, YrsTransaction txn);

    /**
     * Subscribes a given callback function `cb` to changes made by this `YText` instance. Callbacks
     * <br>
     * are triggered whenever a `ytransaction_commit` is called.
     * <br>
     * Returns a subscription ID which can be then used to unsubscribe this callback by using
     * <br>
     * `yunobserve` function.<br>
     * Original signature : <code>YrsSubscription* yweak_observe(const YrsBranch*, void*, yweak_observe_cb_callback*)</code><br>
     * <i>native declaration : libyrs.h:2074</i>
     */
    YrsSubscription yweak_observe(YrsBranch weak, Pointer state, yweak_observe_cb_callback cb);

    /**
     * Original signature : <code>Weak* ymap_link(const YrsBranch*, const YrsTransaction*, const char*)</code><br>
     * <i>native declaration : libyrs.h:2076</i>
     */
    YrsLinkSource ymap_link(YrsBranch map, YrsTransaction txn, String key);

    /**
     * Original signature : <code>Weak* ymap_link(const YrsBranch*, const YrsTransaction*, const char*)</code><br>
     * <i>native declaration : libyrs.h:2076</i>
     */
    YrsLinkSource ymap_link(YrsBranch map, YrsTransaction txn, Pointer key);

    /**
     * Original signature : <code>Weak* ytext_quote(const YrsBranch*, YrsTransaction*, uint32_t, uint32_t, int8_t, int8_t)</code><br>
     * <i>native declaration : libyrs.h:2078</i>
     */
    YrsLinkSource ytext_quote(YrsBranch text, YrsTransaction txn, int start_index, int end_index, byte start_exclusive, byte end_exclusive);

    /**
     * Original signature : <code>Weak* yarray_quote(const YrsBranch*, YrsTransaction*, uint32_t, uint32_t, int8_t, int8_t)</code><br>
     * <i>native declaration : libyrs.h:2080</i>
     */
    YrsLinkSource yarray_quote(YrsBranch array, YrsTransaction txn, int start_index, int end_index, byte start_exclusive, byte end_exclusive);

    /**
     * Returns a logical identifier for a given shared collection. That collection must be alive at
     * <br>
     * the moment of function call.<br>
     * Original signature : <code>YrsBranchId ybranch_id(const YrsBranch*)</code><br>
     * <i>native declaration : libyrs.h:2086</i>
     */
    YrsBranchId.ByValue ybranch_id(YrsBranch yrsBranch);

    /**
     * Given a logical identifier, returns a physical pointer to a shared collection.
     * <br>
     * Returns null if collection was not found - either because it was not defined or not synchronized
     * <br>
     * yet.
     * <br>
     * Returned pointer may still point to deleted collection. In such case a subsequent `ybranch_alive`
     * <br>
     * function call is required.<br>
     * Original signature : <code>YrsBranch* ybranch_get(YrsBranchId*, YrsTransaction*)</code><br>
     * <i>native declaration : libyrs.h:2095</i>
     */
    YrsBranch ybranch_get(YrsBranchId branch_id, YrsTransaction txn);

    /**
     * Check if current yrsBranch is still alive (returns `Y_TRUE`, otherwise `Y_FALSE`).
     * <br>
     * If it was deleted, this yrsBranch pointer is no longer a valid pointer and cannot be used to
     * <br>
     * execute any functions using it.<br>
     * Original signature : <code>uint8_t ybranch_alive(YrsBranch*)</code><br>
     * <i>native declaration : libyrs.h:2102</i>
     */
    byte ybranch_alive(YrsBranch yrsBranch);


    /* ─────  Awareness API  ──────────────────────────────────────────── */

    /**
     * YAwarenessw* y_awareness_new(YrsDoc*)
     */
    Pointer y_awareness_new(YrsDoc doc);

    /**
     * void y_awareness_destroy(YAwarenessw*)
     */
    void y_awareness_destroy(Pointer aw);

    /**
     * void y_awareness_set_local_state(YAwarenessw*, const char* json)           *
     * Pass null to clear the local state
     */
    void y_awareness_set_local_state(Pointer aw, String json /* @Nullable */);

    /**
     * char* y_awareness_get_local_state(YAwarenessw*)                           *
     * Returns NULL when no local state has been set.                            *
     * Free the returned pointer with ystring_destroy.
     */
    Pointer y_awareness_get_local_state(Pointer aw);

    /**
     * uint8_t* y_awareness_encode_update(YAwarenessw*,                          *
     * const uint64_t* clientIds ,                       *
     * int len, IntByReference outLen)                                   *
     * When you’re done with the returned buffer call                            *
     * ybinary_destroy(ptr, outLen.getValue())
     */
    Pointer y_awareness_encode_update(Pointer aw,
                                      long[] clientIds /* @Nullable */,
                                      int len,
                                      IntByReference outLen);

    /**
     * void y_awareness_apply_update(YAwarenessw*, const uint8_t* data, int len)
     */
    void y_awareness_apply_update(Pointer aw, Pointer data, int len);

    /** void y_awareness_remove_states(YAwarenessw*, long* ids, int len) */
    void y_awareness_remove_states(Pointer aw, long[] clientIds, int len);

    /** char* y_awareness_get_states(YAwarenessw*) – free with ystring_destroy */
    Pointer y_awareness_get_states(Pointer aw);

    /** YStickyIndex* ysticky_index_from_json(const char* json) */
    YrsStickyIndex ysticky_index_from_json(String json);

    /** char* ysticky_index_to_json(const YStickyIndex*)   (free with ystring_destroy) */
    Pointer ysticky_index_to_json(YrsStickyIndex pos);

    Pointer y_absolute_from_sticky_index(YrsStickyIndex sticky, YrsDoc doc);
    /* struct layout: uint32 index @0, int8 assoc @4 */
    void    y_absolute_position_destroy(Pointer abs);
}
